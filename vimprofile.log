SCRIPT  /usr/share/nvim/runtime/ftplugin/cpp.vim
Sourced 2 times
Total time:   0.001160
 Self time:   0.000989

count  total (s)   self (s)
                            " Vim filetype plugin file
                            " Language:	C++
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2001 Jan 15
                            
                            " Only do this when not done yet for this buffer
    2              0.000006 if exists("b:did_ftplugin")
                              finish
    2              0.000001 endif
                            
                            " Behaves just like C
    2   0.001134   0.000962 runtime! ftplugin/c.vim ftplugin/c_*.vim ftplugin/c/*.vim

SCRIPT  /usr/share/nvim/runtime/ftplugin/c.vim
Sourced 2 times
Total time:   0.000166
 Self time:   0.000166

count  total (s)   self (s)
                            " Vim filetype plugin file
                            " Language:	C
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2017 Sep 28
                            
                            " Only do this when not done yet for this buffer
    2              0.000004 if exists("b:did_ftplugin")
                              finish
    2              0.000001 endif
                            
                            " Don't load another plugin for this buffer
    2              0.000004 let b:did_ftplugin = 1
                            
                            " Using line continuation here.
    2              0.000010 let s:cpo_save = &cpo
    2              0.000019 set cpo-=C
                            
    2              0.000003 let b:undo_ftplugin = "setl fo< com< ofu<"
                            
                            " Set 'formatoptions' to break comment lines but not other lines,
                            " and insert the comment leader when hitting <CR> or using "o".
    2              0.000020 setlocal fo-=t fo+=croql
                            
                            " Set completion with CTRL-X CTRL-O to autoloaded function.
    2              0.000006 if exists('&ofu')
    2              0.000008   setlocal ofu=ccomplete#Complete
    2              0.000001 endif
                            
                            " Set 'comments' to format dashed lists in comments.
    2              0.000006 setlocal comments=sO:*\ -,mO:*\ \ ,exO:*/,s1:/*,mb:*,ex:*/,://
                            
                            " When the matchit plugin is loaded, this makes the % command skip parens and
                            " braces in comments properly.
    2              0.000004 let b:match_words = '^\s*#\s*if\(\|def\|ndef\)\>:^\s*#\s*elif\>:^\s*#\s*else\>:^\s*#\s*endif\>'
    2              0.000003 let b:match_skip = 's:comment\|string\|character\|special'
                            
                            " Win32 can filter files in the browse dialog
    2              0.000012 if (has("gui_win32") || has("gui_gtk")) && !exists("b:browsefilter")
                              if &ft == "cpp"
                                let b:browsefilter = "C++ Source Files (*.cpp *.c++)\t*.cpp;*.c++\n" .
                            	  \ "C Header Files (*.h)\t*.h\n" .
                            	  \ "C Source Files (*.c)\t*.c\n" .
                            	  \ "All Files (*.*)\t*.*\n"
                              elseif &ft == "ch"
                                let b:browsefilter = "Ch Source Files (*.ch *.chf)\t*.ch;*.chf\n" .
                            	  \ "C Header Files (*.h)\t*.h\n" .
                            	  \ "C Source Files (*.c)\t*.c\n" .
                            	  \ "All Files (*.*)\t*.*\n"
                              else
                                let b:browsefilter = "C Source Files (*.c)\t*.c\n" .
                            	  \ "C Header Files (*.h)\t*.h\n" .
                            	  \ "Ch Source Files (*.ch *.chf)\t*.ch;*.chf\n" .
                            	  \ "C++ Source Files (*.cpp *.c++)\t*.cpp;*.c++\n" .
                            	  \ "All Files (*.*)\t*.*\n"
                              endif
    2              0.000002 endif
                            
    2              0.000003 let b:man_default_sects = '3,2'
                            
    2              0.000010 let &cpo = s:cpo_save
    2              0.000006 unlet s:cpo_save

SCRIPT  /usr/share/nvim/runtime/indent/cpp.vim
Sourced 2 times
Total time:   0.000038
 Self time:   0.000038

count  total (s)   self (s)
                            " Vim indent file
                            " Language:	C++
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2008 Nov 29
                            
                            " Only load this indent file when no other was loaded.
    2              0.000005 if exists("b:did_indent")
                               finish
    2              0.000001 endif
    2              0.000003 let b:did_indent = 1
                            
                            " C++ indenting is built-in, thus this is very simple
    2              0.000008 setlocal cindent
                            
    2              0.000004 let b:undo_indent = "setl cin<"

SCRIPT  /usr/share/nvim/runtime/syntax/cpp.vim
Sourced 2 times
Total time:   0.003257
 Self time:   0.000431

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	C++
                            " Current Maintainer:	vim-jp (https://github.com/vim-jp/vim-cpp)
                            " Previous Maintainer:	Ken Shan <ccshan@post.harvard.edu>
                            " Last Change:	2017 Jun 05
                            
                            " quit when a syntax file was already loaded
    2              0.000005 if exists("b:current_syntax")
                              finish
    2              0.000001 endif
                            
                            " Read the C syntax to start with
    2   0.003002   0.000176 runtime! syntax/c.vim
    2              0.000002 unlet b:current_syntax
                            
                            " C++ extensions
    2              0.000005 syn keyword cppStatement	new delete this friend using
    2              0.000002 syn keyword cppAccess		public protected private
    2              0.000003 syn keyword cppModifier		inline virtual explicit export
    2              0.000002 syn keyword cppType		bool wchar_t
    2              0.000003 syn keyword cppExceptions	throw try catch
    2              0.000002 syn keyword cppOperator		operator typeid
    2              0.000004 syn keyword cppOperator		and bitor or xor compl bitand and_eq or_eq xor_eq not not_eq
    2              0.000009 syn match cppCast		"\<\(const\|static\|dynamic\|reinterpret\)_cast\s*<"me=e-1
    2              0.000007 syn match cppCast		"\<\(const\|static\|dynamic\|reinterpret\)_cast\s*$"
    2              0.000002 syn keyword cppStorageClass	mutable
    2              0.000003 syn keyword cppStructure	class typename template namespace
    2              0.000002 syn keyword cppBoolean		true false
    2              0.000002 syn keyword cppConstant		__cplusplus
                            
                            " C++ 11 extensions
    2              0.000004 if !exists("cpp_no_cpp11")
    2              0.000002   syn keyword cppModifier	override final
    2              0.000002   syn keyword cppType		nullptr_t auto
    2              0.000002   syn keyword cppExceptions	noexcept
    2              0.000003   syn keyword cppStorageClass	constexpr decltype thread_local
    2              0.000002   syn keyword cppConstant	nullptr
    2              0.000002   syn keyword cppConstant	ATOMIC_FLAG_INIT ATOMIC_VAR_INIT
    2              0.000002   syn keyword cppConstant	ATOMIC_BOOL_LOCK_FREE ATOMIC_CHAR_LOCK_FREE
    2              0.000002   syn keyword cppConstant	ATOMIC_CHAR16_T_LOCK_FREE ATOMIC_CHAR32_T_LOCK_FREE
    2              0.000002   syn keyword cppConstant	ATOMIC_WCHAR_T_LOCK_FREE ATOMIC_SHORT_LOCK_FREE
    2              0.000002   syn keyword cppConstant	ATOMIC_INT_LOCK_FREE ATOMIC_LONG_LOCK_FREE
    2              0.000002   syn keyword cppConstant	ATOMIC_LLONG_LOCK_FREE ATOMIC_POINTER_LOCK_FREE
    2              0.000042   syn region cppRawString	matchgroup=cppRawStringDelimiter start=+\%(u8\|[uLU]\)\=R"\z([[:alnum:]_{}[\]#<>%:;.?*\+\-/\^&|~!=,"']\{,16}\)(+ end=+)\z1"+ contains=@Spell
    2              0.000001 endif
                            
                            " C++ 14 extensions
    2              0.000003 if !exists("cpp_no_cpp14")
    2              0.000001   syn case ignore
    2              0.000009   syn match cppNumber		display "\<0b[01]\('\=[01]\+\)*\(u\=l\{0,2}\|ll\=u\)\>"
    2              0.000008   syn match cppNumber		display "\<[1-9]\('\=\d\+\)*\(u\=l\{0,2}\|ll\=u\)\>" contains=cFloat
    2              0.000005   syn match cppNumber		display "\<0x\x\('\=\x\+\)*\(u\=l\{0,2}\|ll\=u\)\>"
    2              0.000001   syn case match
    2              0.000001 endif
                            
                            " The minimum and maximum operators in GNU C++
    2              0.000003 syn match cppMinMax "[<>]?"
                            
                            " Default highlighting
    2              0.000002 hi def link cppAccess		cppStatement
    2              0.000002 hi def link cppCast		cppStatement
    2              0.000007 hi def link cppExceptions		Exception
    2              0.000007 hi def link cppOperator		Operator
    2              0.000005 hi def link cppStatement		Statement
    2              0.000006 hi def link cppModifier		Type
    2              0.000006 hi def link cppType		Type
    2              0.000005 hi def link cppStorageClass	StorageClass
    2              0.000005 hi def link cppStructure		Structure
    2              0.000005 hi def link cppBoolean		Boolean
    2              0.000005 hi def link cppConstant		Constant
    2              0.000006 hi def link cppRawStringDelimiter	Delimiter
    2              0.000006 hi def link cppRawString		String
    2              0.000006 hi def link cppNumber		Number
                            
    2              0.000003 let b:current_syntax = "cpp"
                            
                            " vim: ts=8

SCRIPT  /usr/share/nvim/runtime/syntax/c.vim
Sourced 2 times
Total time:   0.002821
 Self time:   0.002821

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	C
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2019 Apr 23
                            
                            " Quit when a (custom) syntax file was already loaded
    2              0.000005 if exists("b:current_syntax")
                              finish
    2              0.000001 endif
                            
    2              0.000012 let s:cpo_save = &cpo
    2              0.000011 set cpo&vim
                            
    2              0.000021 let s:ft = matchstr(&ft, '^\([^.]\)\+')
                            
                            " Optional embedded Autodoc parsing
                            " To enable it add: let g:c_autodoc = 1
                            " to your .vimrc
    2              0.000003 if exists("c_autodoc")
                              syn include @cAutodoc <sfile>:p:h/autodoc.vim
                              unlet b:current_syntax
    2              0.000001 endif
                            
                            " A bunch of useful C keywords
    2              0.000012 syn keyword	cStatement	goto break return continue asm
    2              0.000004 syn keyword	cLabel		case default
    2              0.000004 syn keyword	cConditional	if else switch
    2              0.000004 syn keyword	cRepeat		while for do
                            
    2              0.000006 syn keyword	cTodo		contained TODO FIXME XXX
                            
                            " It's easy to accidentally add a space after a backslash that was intended
                            " for line continuation.  Some compilers allow it, which makes it
                            " unpredictable and should be avoided.
    2              0.000009 syn match	cBadContinuation contained "\\\s\+$"
                            
                            " cCommentGroup allows adding matches for special things in comments
    2              0.000013 syn cluster	cCommentGroup	contains=cTodo,cBadContinuation
                            
                            " String and Character constants
                            " Highlight special characters (those which have a backslash) differently
    2              0.000012 syn match	cSpecial	display contained "\\\(x\x\+\|\o\{1,3}\|.\|$\)"
    2              0.000004 if !exists("c_no_utf")
    2              0.000009   syn match	cSpecial	display contained "\\\(u\x\{4}\|U\x\{8}\)"
    2              0.000001 endif
                            
    2              0.000003 if !exists("c_no_cformat")
                              " Highlight % items in strings.
    2              0.000003   if !exists("c_no_c99") " ISO C99
    2              0.000019     syn match	cFormat		display "%\(\d\+\$\)\=[-+' #0*]*\(\d*\|\*\|\*\d\+\$\)\(\.\(\d*\|\*\|\*\d\+\$\)\)\=\([hlLjzt]\|ll\|hh\)\=\([aAbdiuoxXDOUfFeEgGcCsSpn]\|\[\^\=.[^]]*\]\)" contained
                              else
                                syn match	cFormat		display "%\(\d\+\$\)\=[-+' #0*]*\(\d*\|\*\|\*\d\+\$\)\(\.\(\d*\|\*\|\*\d\+\$\)\)\=\([hlL]\|ll\)\=\([bdiuoxXDOUfeEgGcCsSpn]\|\[\^\=.[^]]*\]\)" contained
    2              0.000001   endif
    2              0.000005   syn match	cFormat		display "%%" contained
    2              0.000001 endif
                            
                            " cCppString: same as cString, but ends at end of line
    2              0.000007 if s:ft ==# "cpp" && !exists("cpp_no_cpp11") && !exists("c_no_cformat")
                              " ISO C++11
    2              0.000027   syn region	cString		start=+\(L\|u\|u8\|U\|R\|LR\|u8R\|uR\|UR\)\="+ skip=+\\\\\|\\"+ end=+"+ contains=cSpecial,cFormat,@Spell extend
    2              0.000026   syn region 	cCppString	start=+\(L\|u\|u8\|U\|R\|LR\|u8R\|uR\|UR\)\="+ skip=+\\\\\|\\"\|\\$+ excludenl end=+"+ end='$' contains=cSpecial,cFormat,@Spell
                            elseif s:ft ==# "c" && !exists("c_no_c11") && !exists("c_no_cformat")
                              " ISO C99
                              syn region	cString		start=+\%(L\|U\|u8\)\="+ skip=+\\\\\|\\"+ end=+"+ contains=cSpecial,cFormat,@Spell extend
                              syn region	cCppString	start=+\%(L\|U\|u8\)\="+ skip=+\\\\\|\\"\|\\$+ excludenl end=+"+ end='$' contains=cSpecial,cFormat,@Spell
                            else
                              " older C or C++
                              syn match	cFormat		display "%%" contained
                              syn region	cString		start=+L\="+ skip=+\\\\\|\\"+ end=+"+ contains=cSpecial,cFormat,@Spell extend
                              syn region	cCppString	start=+L\="+ skip=+\\\\\|\\"\|\\$+ excludenl end=+"+ end='$' contains=cSpecial,cFormat,@Spell
    2              0.000001 endif
                            
    2              0.000023 syn region	cCppSkip	contained start="^\s*\(%:\|#\)\s*\(if\>\|ifdef\>\|ifndef\>\)" skip="\\$" end="^\s*\(%:\|#\)\s*endif\>" contains=cSpaceError,cCppSkip
                            
    2              0.000007 syn cluster	cStringGroup	contains=cCppString,cCppSkip
                            
    2              0.000006 syn match	cCharacter	"L\='[^\\]'"
    2              0.000008 syn match	cCharacter	"L'[^']*'" contains=cSpecial
    2              0.000003 if exists("c_gnu")
                              syn match	cSpecialError	"L\='\\[^'\"?\\abefnrtv]'"
                              syn match	cSpecialCharacter "L\='\\['\"?\\abefnrtv]'"
    2              0.000001 else
    2              0.000006   syn match	cSpecialError	"L\='\\[^'\"?\\abfnrtv]'"
    2              0.000006   syn match	cSpecialCharacter "L\='\\['\"?\\abfnrtv]'"
    2              0.000001 endif
    2              0.000006 syn match	cSpecialCharacter display "L\='\\\o\{1,3}'"
    2              0.000005 syn match	cSpecialCharacter display "'\\x\x\{1,2}'"
    2              0.000004 syn match	cSpecialCharacter display "L'\\x\x\+'"
                            
    2              0.000008 if (s:ft ==# "c" && !exists("c_no_c11")) || (s:ft ==# "cpp" && !exists("cpp_no_cpp11"))
                              " ISO C11 or ISO C++ 11
    2              0.000003   if exists("c_no_cformat")
                                syn region	cString		start=+\%(U\|u8\=\)"+ skip=+\\\\\|\\"+ end=+"+ contains=cSpecial,@Spell extend
    2              0.000001   else
    2              0.000016     syn region	cString		start=+\%(U\|u8\=\)"+ skip=+\\\\\|\\"+ end=+"+ contains=cSpecial,cFormat,@Spell extend
    2              0.000001   endif
    2              0.000005   syn match	cCharacter	"[Uu]'[^\\]'"
    2              0.000008   syn match	cCharacter	"[Uu]'[^']*'" contains=cSpecial
    2              0.000008   if exists("c_gnu")
                                syn match	cSpecialError	"[Uu]'\\[^'\"?\\abefnrtv]'"
                                syn match	cSpecialCharacter "[Uu]'\\['\"?\\abefnrtv]'"
    2              0.000001   else
    2              0.000006     syn match	cSpecialError	"[Uu]'\\[^'\"?\\abfnrtv]'"
    2              0.000005     syn match	cSpecialCharacter "[Uu]'\\['\"?\\abfnrtv]'"
    2              0.000001   endif
    2              0.000005   syn match	cSpecialCharacter display "[Uu]'\\\o\{1,3}'"
    2              0.000005   syn match	cSpecialCharacter display "[Uu]'\\x\x\+'"
    2              0.000001 endif
                            
                            "when wanted, highlight trailing white space
    2              0.000003 if exists("c_space_errors")
                              if !exists("c_no_trail_space_error")
                                syn match	cSpaceError	display excludenl "\s\+$"
                              endif
                              if !exists("c_no_tab_space_error")
                                syn match	cSpaceError	display " \+\t"me=e-1
                              endif
    2              0.000001 endif
                            
                            " This should be before cErrInParen to avoid problems with #define ({ xxx })
    2              0.000003 if exists("c_curly_error")
                              syn match cCurlyError "}"
                              syn region	cBlock		start="{" end="}" contains=ALLBUT,cBadBlock,cCurlyError,@cParenGroup,cErrInParen,cCppParen,cErrInBracket,cCppBracket,@cStringGroup,@Spell fold
    2              0.000001 else
    2              0.000007   syn region	cBlock		start="{" end="}" transparent fold
    2              0.000001 endif
                            
                            " Catch errors caused by wrong parenthesis and brackets.
                            " Also accept <% for {, %> for }, <: for [ and :> for ] (C99)
                            " But avoid matching <::.
    2              0.000053 syn cluster	cParenGroup	contains=cParenError,cIncluded,cSpecial,cCommentSkip,cCommentString,cComment2String,@cCommentGroup,cCommentStartError,cUserLabel,cBitField,cOctalZero,@cCppOutInGroup,cFormat,cNumber,cFloat,cOctal,cOctalError,cNumbersCom
    2              0.000003 if exists("c_no_curly_error")
                              if s:ft ==# 'cpp' && !exists("cpp_no_cpp11")
                                syn region	cParen		transparent start='(' end=')' contains=ALLBUT,@cParenGroup,cCppParen,@cStringGroup,@Spell
                                " cCppParen: same as cParen but ends at end-of-line; used in cDefine
                                syn region	cCppParen	transparent start='(' skip='\\$' excludenl end=')' end='$' contained contains=ALLBUT,@cParenGroup,cParen,cString,@Spell
                                syn match	cParenError	display ")"
                                syn match	cErrInParen	display contained "^^<%\|^%>"
                              else
                                syn region	cParen		transparent start='(' end=')' end='}'me=s-1 contains=ALLBUT,cBlock,@cParenGroup,cCppParen,@cStringGroup,@Spell
                                " cCppParen: same as cParen but ends at end-of-line; used in cDefine
                                syn region	cCppParen	transparent start='(' skip='\\$' excludenl end=')' end='$' contained contains=ALLBUT,@cParenGroup,cParen,cString,@Spell
                                syn match	cParenError	display ")"
                                syn match	cErrInParen	display contained "^[{}]\|^<%\|^%>"
                              endif
    2              0.000004 elseif exists("c_no_bracket_error")
                              if s:ft ==# 'cpp' && !exists("cpp_no_cpp11")
                                syn region	cParen		transparent start='(' end=')' contains=ALLBUT,@cParenGroup,cCppParen,@cStringGroup,@Spell
                                " cCppParen: same as cParen but ends at end-of-line; used in cDefine
                                syn region	cCppParen	transparent start='(' skip='\\$' excludenl end=')' end='$' contained contains=ALLBUT,@cParenGroup,cParen,cString,@Spell
                                syn match	cParenError	display ")"
                                syn match	cErrInParen	display contained "<%\|%>"
                              else
                                syn region	cParen		transparent start='(' end=')' end='}'me=s-1 contains=ALLBUT,cBlock,@cParenGroup,cCppParen,@cStringGroup,@Spell
                                " cCppParen: same as cParen but ends at end-of-line; used in cDefine
                                syn region	cCppParen	transparent start='(' skip='\\$' excludenl end=')' end='$' contained contains=ALLBUT,@cParenGroup,cParen,cString,@Spell
                                syn match	cParenError	display ")"
                                syn match	cErrInParen	display contained "[{}]\|<%\|%>"
                              endif
    2              0.000001 else
    2              0.000005   if s:ft ==# 'cpp' && !exists("cpp_no_cpp11")
    2              0.000015     syn region	cParen		transparent start='(' end=')' contains=ALLBUT,@cParenGroup,cCppParen,cErrInBracket,cCppBracket,@cStringGroup,@Spell
                                " cCppParen: same as cParen but ends at end-of-line; used in cDefine
    2              0.000020     syn region	cCppParen	transparent start='(' skip='\\$' excludenl end=')' end='$' contained contains=ALLBUT,@cParenGroup,cErrInBracket,cParen,cBracket,cString,@Spell
    2              0.000005     syn match	cParenError	display "[\])]"
    2              0.000004     syn match	cErrInParen	display contained "<%\|%>"
    2              0.000019     syn region	cBracket	transparent start='\[\|<::\@!' end=']\|:>' contains=ALLBUT,@cParenGroup,cErrInParen,cCppParen,cCppBracket,@cStringGroup,@Spell
                              else
                                syn region	cParen		transparent start='(' end=')' end='}'me=s-1 contains=ALLBUT,cBlock,@cParenGroup,cCppParen,cErrInBracket,cCppBracket,@cStringGroup,@Spell
                                " cCppParen: same as cParen but ends at end-of-line; used in cDefine
                                syn region	cCppParen	transparent start='(' skip='\\$' excludenl end=')' end='$' contained contains=ALLBUT,@cParenGroup,cErrInBracket,cParen,cBracket,cString,@Spell
                                syn match	cParenError	display "[\])]"
                                syn match	cErrInParen	display contained "[\]{}]\|<%\|%>"
                                syn region	cBracket	transparent start='\[\|<::\@!' end=']\|:>' end='}'me=s-1 contains=ALLBUT,cBlock,@cParenGroup,cErrInParen,cCppParen,cCppBracket,@cStringGroup,@Spell
    2              0.000001   endif
                              " cCppBracket: same as cParen but ends at end-of-line; used in cDefine
    2              0.000022   syn region	cCppBracket	transparent start='\[\|<::\@!' skip='\\$' excludenl end=']\|:>' end='$' contained contains=ALLBUT,@cParenGroup,cErrInParen,cParen,cBracket,cString,@Spell
    2              0.000005   syn match	cErrInBracket	display contained "[);{}]\|<%\|%>"
    2              0.000001 endif
                            
    2              0.000005 if s:ft ==# 'c' || exists("cpp_no_cpp11")
                              syn region	cBadBlock	keepend start="{" end="}" contained containedin=cParen,cBracket,cBadBlock transparent fold
    2              0.000001 endif
                            
                            "integer number, or floating point number without a dot and with "f".
    2              0.000002 syn case ignore
    2              0.000013 syn match	cNumbers	display transparent "\<\d\|\.\d" contains=cNumber,cFloat,cOctalError,cOctal
                            " Same, but without octal error (for comments)
    2              0.000010 syn match	cNumbersCom	display contained transparent "\<\d\|\.\d" contains=cNumber,cFloat,cOctal
    2              0.000008 syn match	cNumber		display contained "\d\+\(u\=l\{0,2}\|ll\=u\)\>"
                            "hex number
    2              0.000006 syn match	cNumber		display contained "0x\x\+\(u\=l\{0,2}\|ll\=u\)\>"
                            " Flag the first zero of an octal number as something special
    2              0.000008 syn match	cOctal		display contained "0\o\+\(u\=l\{0,2}\|ll\=u\)\>" contains=cOctalZero
    2              0.000004 syn match	cOctalZero	display contained "\<0"
    2              0.000004 syn match	cFloat		display contained "\d\+f"
                            "floating point number, with dot, optional exponent
    2              0.000008 syn match	cFloat		display contained "\d\+\.\d*\(e[-+]\=\d\+\)\=[fl]\="
                            "floating point number, starting with a dot, optional exponent
    2              0.000006 syn match	cFloat		display contained "\.\d\+\(e[-+]\=\d\+\)\=[fl]\=\>"
                            "floating point number, without dot, with exponent
    2              0.000006 syn match	cFloat		display contained "\d\+e[-+]\=\d\+[fl]\=\>"
    2              0.000003 if !exists("c_no_c99")
                              "hexadecimal floating point number, optional leading digits, with dot, with exponent
    2              0.000007   syn match	cFloat		display contained "0x\x*\.\x\+p[-+]\=\d\+[fl]\=\>"
                              "hexadecimal floating point number, with leading digits, optional dot, with exponent
    2              0.000006   syn match	cFloat		display contained "0x\x\+\.\=p[-+]\=\d\+[fl]\=\>"
    2              0.000001 endif
                            
                            " flag an octal number with wrong digits
    2              0.000005 syn match	cOctalError	display contained "0\o*[89]\d*"
    2              0.000001 syn case match
                            
    2              0.000003 if exists("c_comment_strings")
                              " A comment can contain cString, cCharacter and cNumber.
                              " But a "*/" inside a cString in a cComment DOES end the comment!  So we
                              " need to use a special type of cString: cCommentString, which also ends on
                              " "*/", and sees a "*" at the start of the line as comment again.
                              " Unfortunately this doesn't very well work for // type of comments :-(
                              syn match	cCommentSkip	contained "^\s*\*\($\|\s\+\)"
                              syn region cCommentString	contained start=+L\=\\\@<!"+ skip=+\\\\\|\\"+ end=+"+ end=+\*/+me=s-1 contains=cSpecial,cCommentSkip
                              syn region cComment2String	contained start=+L\=\\\@<!"+ skip=+\\\\\|\\"+ end=+"+ end="$" contains=cSpecial
                              syn region  cCommentL	start="//" skip="\\$" end="$" keepend contains=@cCommentGroup,cComment2String,cCharacter,cNumbersCom,cSpaceError,cWrongComTail,@Spell
                              if exists("c_no_comment_fold")
                                " Use "extend" here to have preprocessor lines not terminate halfway a
                                " comment.
                                syn region cComment	matchgroup=cCommentStart start="/\*" end="\*/" contains=@cCommentGroup,cCommentStartError,cCommentString,cCharacter,cNumbersCom,cSpaceError,@Spell extend
                              else
                                syn region cComment	matchgroup=cCommentStart start="/\*" end="\*/" contains=@cCommentGroup,cCommentStartError,cCommentString,cCharacter,cNumbersCom,cSpaceError,@Spell fold extend
                              endif
    2              0.000003 else
    2              0.000016   syn region	cCommentL	start="//" skip="\\$" end="$" keepend contains=@cCommentGroup,cSpaceError,@Spell
    2              0.000008   if exists("c_no_comment_fold")
                                syn region	cComment	matchgroup=cCommentStart start="/\*" end="\*/" contains=@cCommentGroup,cCommentStartError,cSpaceError,@Spell extend
    2              0.000001   else
    2              0.000015     syn region	cComment	matchgroup=cCommentStart start="/\*" end="\*/" contains=@cCommentGroup,cCommentStartError,cSpaceError,@Spell fold extend
    2              0.000001   endif
    2              0.000001 endif
                            " keep a // comment separately, it terminates a preproc. conditional
    2              0.000004 syn match	cCommentError	display "\*/"
    2              0.000004 syn match	cCommentStartError display "/\*"me=e-1 contained
    2              0.000004 syn match	cWrongComTail	display "\*/"
                            
    2              0.000010 syn keyword	cOperator	sizeof
    2              0.000003 if exists("c_gnu")
                              syn keyword	cStatement	__asm__
                              syn keyword	cOperator	typeof __real__ __imag__
    2              0.000001 endif
    2              0.000004 syn keyword	cType		int long short char void
    2              0.000003 syn keyword	cType		signed unsigned float double
    2              0.000004 if !exists("c_no_ansi") || exists("c_ansi_typedefs")
    2              0.000005   syn keyword   cType		size_t ssize_t off_t wchar_t ptrdiff_t sig_atomic_t fpos_t
    2              0.000005   syn keyword   cType		clock_t time_t va_list jmp_buf FILE DIR div_t ldiv_t
    2              0.000008   syn keyword   cType		mbstate_t wctrans_t wint_t wctype_t
    2              0.000001 endif
    2              0.000003 if !exists("c_no_c99") " ISO C99
    2              0.000011   syn keyword	cType		_Bool bool _Complex complex _Imaginary imaginary
    2              0.000003   syn keyword	cType		int8_t int16_t int32_t int64_t
    2              0.000003   syn keyword	cType		uint8_t uint16_t uint32_t uint64_t
    2              0.000003   if !exists("c_no_bsd")
                                " These are BSD specific.
    2              0.000003     syn keyword	cType		u_int8_t u_int16_t u_int32_t u_int64_t
    2              0.000001   endif
    2              0.000003   syn keyword	cType		int_least8_t int_least16_t int_least32_t int_least64_t
    2              0.000003   syn keyword	cType		uint_least8_t uint_least16_t uint_least32_t uint_least64_t
    2              0.000003   syn keyword	cType		int_fast8_t int_fast16_t int_fast32_t int_fast64_t
    2              0.000003   syn keyword	cType		uint_fast8_t uint_fast16_t uint_fast32_t uint_fast64_t
    2              0.000002   syn keyword	cType		intptr_t uintptr_t
    2              0.000002   syn keyword	cType		intmax_t uintmax_t
    2              0.000001 endif
    2              0.000002 if exists("c_gnu")
                              syn keyword	cType		__label__ __complex__ __volatile__
    2              0.000001 endif
                            
    2              0.000003 syn keyword	cStructure	struct union enum typedef
    2              0.000004 syn keyword	cStorageClass	static register auto volatile extern const
    2              0.000002 if exists("c_gnu")
                              syn keyword	cStorageClass	inline __attribute__
    2              0.000001 endif
    2              0.000004 if !exists("c_no_c99") && s:ft !=# 'cpp'
                              syn keyword	cStorageClass	inline restrict
    2              0.000001 endif
    2              0.000002 if !exists("c_no_c11")
    2              0.000003   syn keyword	cStorageClass	_Alignas alignas
    2              0.000007   syn keyword	cOperator	_Alignof alignof
    2              0.000002   syn keyword	cStorageClass	_Atomic
    2              0.000006   syn keyword	cOperator	_Generic
    2              0.000002   syn keyword	cStorageClass	_Noreturn noreturn
    2              0.000006   syn keyword	cOperator	_Static_assert static_assert
    2              0.000002   syn keyword	cStorageClass	_Thread_local thread_local
    2              0.000003   syn keyword   cType		char16_t char32_t
                              " C11 atomics (take down the shield wall!)
    2              0.000003   syn keyword	cType		atomic_bool atomic_char atomic_schar atomic_uchar
    2              0.000003   syn keyword	Ctype		atomic_short atomic_ushort atomic_int atomic_uint
    2              0.000003   syn keyword	cType		atomic_long atomic_ulong atomic_llong atomic_ullong
    2              0.000002   syn keyword	cType		atomic_char16_t atomic_char32_t atomic_wchar_t
    2              0.000002   syn keyword	cType		atomic_int_least8_t atomic_uint_least8_t
    2              0.000002   syn keyword	cType		atomic_int_least16_t atomic_uint_least16_t
    2              0.000002   syn keyword	cType		atomic_int_least32_t atomic_uint_least32_t
    2              0.000002   syn keyword	cType		atomic_int_least64_t atomic_uint_least64_t
    2              0.000002   syn keyword	cType		atomic_int_fast8_t atomic_uint_fast8_t
    2              0.000002   syn keyword	cType		atomic_int_fast16_t atomic_uint_fast16_t
    2              0.000002   syn keyword	cType		atomic_int_fast32_t atomic_uint_fast32_t
    2              0.000002   syn keyword	cType		atomic_int_fast64_t atomic_uint_fast64_t
    2              0.000002   syn keyword	cType		atomic_intptr_t atomic_uintptr_t
    2              0.000002   syn keyword	cType		atomic_size_t atomic_ptrdiff_t
    2              0.000002   syn keyword	cType		atomic_intmax_t atomic_uintmax_t
    2              0.000001 endif
                            
    2              0.000005 if !exists("c_no_ansi") || exists("c_ansi_constants") || exists("c_gnu")
    2              0.000002   if exists("c_gnu")
                                syn keyword cConstant __GNUC__ __FUNCTION__ __PRETTY_FUNCTION__ __func__
    2              0.000001   endif
    2              0.000003   syn keyword cConstant __LINE__ __FILE__ __DATE__ __TIME__ __STDC__
    2              0.000002   syn keyword cConstant __STDC_VERSION__
    2              0.000003   syn keyword cConstant CHAR_BIT MB_LEN_MAX MB_CUR_MAX
    2              0.000003   syn keyword cConstant UCHAR_MAX UINT_MAX ULONG_MAX USHRT_MAX
    2              0.000003   syn keyword cConstant CHAR_MIN INT_MIN LONG_MIN SHRT_MIN
    2              0.000003   syn keyword cConstant CHAR_MAX INT_MAX LONG_MAX SHRT_MAX
    2              0.000007   syn keyword cConstant SCHAR_MIN SINT_MIN SLONG_MIN SSHRT_MIN
    2              0.000022   syn keyword cConstant SCHAR_MAX SINT_MAX SLONG_MAX SSHRT_MAX
    2              0.000003   if !exists("c_no_c99")
    2              0.000013     syn keyword cConstant __func__ __VA_ARGS__
    2              0.000016     syn keyword cConstant LLONG_MIN LLONG_MAX ULLONG_MAX
    2              0.000019     syn keyword cConstant INT8_MIN INT16_MIN INT32_MIN INT64_MIN
    2              0.000019     syn keyword cConstant INT8_MAX INT16_MAX INT32_MAX INT64_MAX
    2              0.000019     syn keyword cConstant UINT8_MAX UINT16_MAX UINT32_MAX UINT64_MAX
    2              0.000020     syn keyword cConstant INT_LEAST8_MIN INT_LEAST16_MIN INT_LEAST32_MIN INT_LEAST64_MIN
    2              0.000020     syn keyword cConstant INT_LEAST8_MAX INT_LEAST16_MAX INT_LEAST32_MAX INT_LEAST64_MAX
    2              0.000019     syn keyword cConstant UINT_LEAST8_MAX UINT_LEAST16_MAX UINT_LEAST32_MAX UINT_LEAST64_MAX
    2              0.000011     syn keyword cConstant INT_FAST8_MIN INT_FAST16_MIN INT_FAST32_MIN INT_FAST64_MIN
    2              0.000003     syn keyword cConstant INT_FAST8_MAX INT_FAST16_MAX INT_FAST32_MAX INT_FAST64_MAX
    2              0.000003     syn keyword cConstant UINT_FAST8_MAX UINT_FAST16_MAX UINT_FAST32_MAX UINT_FAST64_MAX
    2              0.000002     syn keyword cConstant INTPTR_MIN INTPTR_MAX UINTPTR_MAX
    2              0.000002     syn keyword cConstant INTMAX_MIN INTMAX_MAX UINTMAX_MAX
    2              0.000003     syn keyword cConstant PTRDIFF_MIN PTRDIFF_MAX SIG_ATOMIC_MIN SIG_ATOMIC_MAX
    2              0.000003     syn keyword cConstant SIZE_MAX WCHAR_MIN WCHAR_MAX WINT_MIN WINT_MAX
    2              0.000001   endif
    2              0.000005   syn keyword cConstant FLT_RADIX FLT_ROUNDS FLT_DIG FLT_MANT_DIG FLT_EPSILON DBL_DIG DBL_MANT_DIG DBL_EPSILON
    2              0.000005   syn keyword cConstant LDBL_DIG LDBL_MANT_DIG LDBL_EPSILON FLT_MIN FLT_MAX FLT_MIN_EXP FLT_MAX_EXP FLT_MIN_10_EXP FLT_MAX_10_EXP
    2              0.000005   syn keyword cConstant DBL_MIN DBL_MAX DBL_MIN_EXP DBL_MAX_EXP DBL_MIN_10_EXP DBL_MAX_10_EXP LDBL_MIN LDBL_MAX LDBL_MIN_EXP LDBL_MAX_EXP
    2              0.000004   syn keyword cConstant LDBL_MIN_10_EXP LDBL_MAX_10_EXP HUGE_VAL CLOCKS_PER_SEC NULL LC_ALL LC_COLLATE LC_CTYPE LC_MONETARY
    2              0.000005   syn keyword cConstant LC_NUMERIC LC_TIME SIG_DFL SIG_ERR SIG_IGN SIGABRT SIGFPE SIGILL SIGHUP SIGINT SIGSEGV SIGTERM
                              " Add POSIX signals as well...
    2              0.000006   syn keyword cConstant SIGABRT SIGALRM SIGCHLD SIGCONT SIGFPE SIGHUP SIGILL SIGINT SIGKILL SIGPIPE SIGQUIT SIGSEGV
    2              0.000004   syn keyword cConstant SIGSTOP SIGTERM SIGTRAP SIGTSTP SIGTTIN SIGTTOU SIGUSR1 SIGUSR2
    2              0.000004   syn keyword cConstant _IOFBF _IOLBF _IONBF BUFSIZ EOF WEOF FOPEN_MAX FILENAME_MAX L_tmpnam
    2              0.000005   syn keyword cConstant SEEK_CUR SEEK_END SEEK_SET TMP_MAX stderr stdin stdout EXIT_FAILURE EXIT_SUCCESS RAND_MAX
                              " POSIX 2001
    2              0.000004   syn keyword cConstant SIGBUS SIGPOLL SIGPROF SIGSYS SIGURG SIGVTALRM SIGXCPU SIGXFSZ
                              " non-POSIX signals
    2              0.000002   syn keyword cConstant SIGWINCH SIGINFO
                              " Add POSIX errors as well.  List comes from:
                              " http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/errno.h.html
    2              0.000004   syn keyword cConstant E2BIG EACCES EADDRINUSE EADDRNOTAVAIL EAFNOSUPPORT EAGAIN EALREADY EBADF
    2              0.000004   syn keyword cConstant EBADMSG EBUSY ECANCELED ECHILD ECONNABORTED ECONNREFUSED ECONNRESET EDEADLK
    2              0.000004   syn keyword cConstant EDESTADDRREQ EDOM EDQUOT EEXIST EFAULT EFBIG EHOSTUNREACH EIDRM EILSEQ
    2              0.000005   syn keyword cConstant EINPROGRESS EINTR EINVAL EIO EISCONN EISDIR ELOOP EMFILE EMLINK EMSGSIZE
    2              0.000004   syn keyword cConstant EMULTIHOP ENAMETOOLONG ENETDOWN ENETRESET ENETUNREACH ENFILE ENOBUFS ENODATA
    2              0.000005   syn keyword cConstant ENODEV ENOENT ENOEXEC ENOLCK ENOLINK ENOMEM ENOMSG ENOPROTOOPT ENOSPC ENOSR
    2              0.000004   syn keyword cConstant ENOSTR ENOSYS ENOTBLK ENOTCONN ENOTDIR ENOTEMPTY ENOTRECOVERABLE ENOTSOCK ENOTSUP
    2              0.000004   syn keyword cConstant ENOTTY ENXIO EOPNOTSUPP EOVERFLOW EOWNERDEAD EPERM EPIPE EPROTO
    2              0.000004   syn keyword cConstant EPROTONOSUPPORT EPROTOTYPE ERANGE EROFS ESPIPE ESRCH ESTALE ETIME ETIMEDOUT
    2              0.000003   syn keyword cConstant ETXTBSY EWOULDBLOCK EXDEV
                              " math.h
    2              0.000004   syn keyword cConstant M_E M_LOG2E M_LOG10E M_LN2 M_LN10 M_PI M_PI_2 M_PI_4
    2              0.000003   syn keyword cConstant M_1_PI M_2_PI M_2_SQRTPI M_SQRT2 M_SQRT1_2
    2              0.000001 endif
    2              0.000003 if !exists("c_no_c99") " ISO C99
    2              0.000002   syn keyword cConstant true false
    2              0.000001 endif
                            
                            " Accept %: for # (C99)
    2              0.000041 syn region	cPreCondit	start="^\s*\zs\(%:\|#\)\s*\(if\|ifdef\|ifndef\|elif\)\>" skip="\\$" end="$" keepend contains=cComment,cCommentL,cCppString,cCharacter,cCppParen,cParenError,cNumbers,cCommentError,cSpaceError
    2              0.000008 syn match	cPreConditMatch	display "^\s*\zs\(%:\|#\)\s*\(else\|endif\)\>"
    2              0.000007 if !exists("c_no_if0")
    2              0.000013   syn cluster	cCppOutInGroup	contains=cCppInIf,cCppInElse,cCppInElse2,cCppOutIf,cCppOutIf2,cCppOutElse,cCppInSkip,cCppOutSkip
    2              0.000020   syn region	cCppOutWrapper	start="^\s*\zs\(%:\|#\)\s*if\s\+0\+\s*\($\|//\|/\*\|&\)" end=".\@=\|$" contains=cCppOutIf,cCppOutElse,@NoSpell fold
    2              0.000014   syn region	cCppOutIf	contained start="0\+" matchgroup=cCppOutWrapper end="^\s*\(%:\|#\)\s*endif\>" contains=cCppOutIf2,cCppOutElse
    2              0.000004   if !exists("c_no_if0_fold")
    2              0.000020     syn region	cCppOutIf2	contained matchgroup=cCppOutWrapper start="0\+" end="^\s*\(%:\|#\)\s*\(else\>\|elif\s\+\(0\+\s*\($\|//\|/\*\|&\)\)\@!\|endif\>\)"me=s-1 contains=cSpaceError,cCppOutSkip,@Spell fold
                              else
                                syn region	cCppOutIf2	contained matchgroup=cCppOutWrapper start="0\+" end="^\s*\(%:\|#\)\s*\(else\>\|elif\s\+\(0\+\s*\($\|//\|/\*\|&\)\)\@!\|endif\>\)"me=s-1 contains=cSpaceError,cCppOutSkip,@Spell
    2              0.000001   endif
    2              0.000024   syn region	cCppOutElse	contained matchgroup=cCppOutWrapper start="^\s*\(%:\|#\)\s*\(else\|elif\)" end="^\s*\(%:\|#\)\s*endif\>"me=s-1 contains=TOP,cPreCondit
    2              0.000016   syn region	cCppInWrapper	start="^\s*\zs\(%:\|#\)\s*if\s\+0*[1-9]\d*\s*\($\|//\|/\*\||\)" end=".\@=\|$" contains=cCppInIf,cCppInElse fold
    2              0.000018   syn region	cCppInIf	contained matchgroup=cCppInWrapper start="\d\+" end="^\s*\(%:\|#\)\s*endif\>" contains=TOP,cPreCondit
    2              0.000003   if !exists("c_no_if0_fold")
    2              0.000017     syn region	cCppInElse	contained start="^\s*\(%:\|#\)\s*\(else\>\|elif\s\+\(0*[1-9]\d*\s*\($\|//\|/\*\||\)\)\@!\)" end=".\@=\|$" containedin=cCppInIf contains=cCppInElse2 fold
                              else
                                syn region	cCppInElse	contained start="^\s*\(%:\|#\)\s*\(else\>\|elif\s\+\(0*[1-9]\d*\s*\($\|//\|/\*\||\)\)\@!\)" end=".\@=\|$" containedin=cCppInIf contains=cCppInElse2
    2              0.000003   endif
    2              0.000019   syn region	cCppInElse2	contained matchgroup=cCppInWrapper start="^\s*\(%:\|#\)\s*\(else\|elif\)\([^/]\|/[^/*]\)*" end="^\s*\(%:\|#\)\s*endif\>"me=s-1 contains=cSpaceError,cCppOutSkip,@Spell
    2              0.000022   syn region	cCppOutSkip	contained start="^\s*\(%:\|#\)\s*\(if\>\|ifdef\>\|ifndef\>\)" skip="\\$" end="^\s*\(%:\|#\)\s*endif\>" contains=cSpaceError,cCppOutSkip
    2              0.000025   syn region	cCppInSkip	contained matchgroup=cCppInWrapper start="^\s*\(%:\|#\)\s*\(if\s\+\(\d\+\s*\($\|//\|/\*\||\|&\)\)\@!\|ifdef\>\|ifndef\>\)" skip="\\$" end="^\s*\(%:\|#\)\s*endif\>" containedin=cCppOutElse,cCppInIf,cCppInSkip contains=TOP,cPreProc
    2              0.000001 endif
    2              0.000017 syn region	cIncluded	display contained start=+"+ skip=+\\\\\|\\"+ end=+"+
    2              0.000011 syn match	cIncluded	display contained "<[^>]*>"
    2              0.000017 syn match	cInclude	display "^\s*\zs\(%:\|#\)\s*include\>\s*["<]" contains=cIncluded
                            "syn match cLineSkip	"\\$"
    2              0.000061 syn cluster	cPreProcGroup	contains=cPreCondit,cIncluded,cInclude,cDefine,cErrInParen,cErrInBracket,cUserLabel,cSpecial,cOctalZero,cCppOutWrapper,cCppInWrapper,@cCppOutInGroup,cFormat,cNumber,cFloat,cOctal,cOctalError,cNumbersCom,cString,cCommentSkip,cCommentString,cComment2String,@cCommentGroup,cCommentStartError,cParen,cBracket,cMulti,cBadBlock
    2              0.000016 syn region	cDefine		start="^\s*\zs\(%:\|#\)\s*\(define\|undef\)\>" skip="\\$" end="$" keepend contains=ALLBUT,@cPreProcGroup,@Spell
    2              0.000017 syn region	cPreProc	start="^\s*\zs\(%:\|#\)\s*\(pragma\>\|line\>\|warning\>\|warn\>\|error\>\)" skip="\\$" end="$" keepend contains=ALLBUT,@cPreProcGroup,@Spell
                            
                            " Optional embedded Autodoc parsing
    2              0.000003 if exists("c_autodoc")
                              syn match cAutodocReal display contained "\%(//\|[/ \t\v]\*\|^\*\)\@2<=!.*" contains=@cAutodoc containedin=cComment,cCommentL
                              syn cluster cCommentGroup add=cAutodocReal
                              syn cluster cPreProcGroup add=cAutodocReal
    2              0.000001 endif
                            
                            " Highlight User Labels
    2              0.000046 syn cluster	cMultiGroup	contains=cIncluded,cSpecial,cCommentSkip,cCommentString,cComment2String,@cCommentGroup,cCommentStartError,cUserCont,cUserLabel,cBitField,cOctalZero,cCppOutWrapper,cCppInWrapper,@cCppOutInGroup,cFormat,cNumber,cFloat,cOctal,cOctalError,cNumbersCom,cCppParen,cCppBracket,cCppString
    2              0.000005 if s:ft ==# 'c' || exists("cpp_no_cpp11")
                              syn region	cMulti		transparent start='?' skip='::' end=':' contains=ALLBUT,@cMultiGroup,@Spell,@cStringGroup
    2              0.000001 endif
                            " Avoid matching foo::bar() in C++ by requiring that the next char is not ':'
    2              0.000004 syn cluster	cLabelGroup	contains=cUserLabel
    2              0.000012 syn match	cUserCont	display "^\s*\zs\I\i*\s*:$" contains=@cLabelGroup
    2              0.000006 syn match	cUserCont	display ";\s*\zs\I\i*\s*:$" contains=@cLabelGroup
    2              0.000002 if s:ft ==# 'cpp'
    2              0.000010   syn match	cUserCont	display "^\s*\zs\%(class\|struct\|enum\)\@!\I\i*\s*:[^:]"me=e-1 contains=@cLabelGroup
    2              0.000008   syn match	cUserCont	display ";\s*\zs\%(class\|struct\|enum\)\@!\I\i*\s*:[^:]"me=e-1 contains=@cLabelGroup
                            else
                              syn match	cUserCont	display "^\s*\zs\I\i*\s*:[^:]"me=e-1 contains=@cLabelGroup
                              syn match	cUserCont	display ";\s*\zs\I\i*\s*:[^:]"me=e-1 contains=@cLabelGroup
    2              0.000001 endif
                            
    2              0.000004 syn match	cUserLabel	display "\I\i*" contained
                            
                            " Avoid recognizing most bitfields as labels
    2              0.000008 syn match	cBitField	display "^\s*\zs\I\i*\s*:\s*[1-9]"me=e-1 contains=cType
    2              0.000007 syn match	cBitField	display ";\s*\zs\I\i*\s*:\s*[1-9]"me=e-1 contains=cType
                            
    2              0.000003 if exists("c_minlines")
                              let b:c_minlines = c_minlines
    2              0.000001 else
    2              0.000003   if !exists("c_no_if0")
    2              0.000004     let b:c_minlines = 50	" #if 0 constructs can be long
                              else
                                let b:c_minlines = 15	" mostly for () constructs
    2              0.000001   endif
    2              0.000001 endif
    2              0.000003 if exists("c_curly_error")
                              syn sync fromstart
    2              0.000001 else
    2              0.000010   exec "syn sync ccomment cComment minlines=" . b:c_minlines
    2              0.000001 endif
                            
                            " Define the default highlighting.
                            " Only used when an item doesn't have highlighting yet
    2              0.000006 hi def link cFormat		cSpecial
    2              0.000003 hi def link cCppString		cString
    2              0.000002 hi def link cCommentL		cComment
    2              0.000002 hi def link cCommentStart	cComment
    2              0.000011 hi def link cLabel		Label
    2              0.000007 hi def link cUserLabel		Label
    2              0.000007 hi def link cConditional	Conditional
    2              0.000006 hi def link cRepeat		Repeat
    2              0.000006 hi def link cCharacter		Character
    2              0.000003 hi def link cSpecialCharacter	cSpecial
    2              0.000010 hi def link cNumber		Number
    2              0.000007 hi def link cOctal		Number
    2              0.000006 hi def link cOctalZero		PreProc	 " link this to Error if you want
    2              0.000006 hi def link cFloat		Float
    2              0.000002 hi def link cOctalError		cError
    2              0.000002 hi def link cParenError		cError
    2              0.000002 hi def link cErrInParen		cError
    2              0.000002 hi def link cErrInBracket	cError
    2              0.000002 hi def link cCommentError	cError
    2              0.000002 hi def link cCommentStartError	cError
    2              0.000002 hi def link cSpaceError		cError
    2              0.000002 hi def link cWrongComTail	cError
    2              0.000002 hi def link cSpecialError	cError
    2              0.000002 hi def link cCurlyError		cError
    2              0.000012 hi def link cOperator		Operator
    2              0.000006 hi def link cStructure		Structure
    2              0.000006 hi def link cStorageClass	StorageClass
    2              0.000006 hi def link cInclude		Include
    2              0.000006 hi def link cPreProc		PreProc
    2              0.000006 hi def link cDefine		Macro
    2              0.000006 hi def link cIncluded		cString
    2              0.000006 hi def link cError		Error
    2              0.000006 hi def link cStatement		Statement
    2              0.000002 hi def link cCppInWrapper	cCppOutWrapper
    2              0.000005 hi def link cCppOutWrapper	cPreCondit
    2              0.000005 hi def link cPreConditMatch	cPreCondit
    2              0.000008 hi def link cPreCondit		PreCondit
    2              0.000007 hi def link cType		Type
    2              0.000006 hi def link cConstant		Constant
    2              0.000003 hi def link cCommentString	cString
    2              0.000003 hi def link cComment2String	cString
    2              0.000002 hi def link cCommentSkip	cComment
    2              0.000007 hi def link cString		String
    2              0.000006 hi def link cComment		Comment
    2              0.000007 hi def link cSpecial		SpecialChar
    2              0.000006 hi def link cTodo		Todo
    2              0.000007 hi def link cBadContinuation	Error
    2              0.000002 hi def link cCppOutSkip		cCppOutIf2
    2              0.000002 hi def link cCppInElse2		cCppOutIf2
    2              0.000002 hi def link cCppOutIf2		cCppOut
    2              0.000006 hi def link cCppOut		Comment
                            
    2              0.000003 let b:current_syntax = "c"
                            
    2              0.000003 unlet s:ft
                            
    2              0.000013 let &cpo = s:cpo_save
    2              0.000002 unlet s:cpo_save
                            " vim: ts=8

FUNCTION  <SNR>17_fzf_fnamemodify()
    Defined: ~/.system/config/nvim/plugged/fzf/plugin/fzf.vim line 106
Called 2 times
Total time:   0.000028
 Self time:   0.000013

count  total (s)   self (s)
    2   0.000026   0.000011   return s:fzf_call('fnamemodify', a:fname, a:mods)

FUNCTION  <SNR>36_EchoEllipsis()
    Defined: ~/.system/config/nvim/plugged/LanguageClient-neovim/autoload/LanguageClient.vim line 39
Called 3 times
Total time:   0.000101
 Self time:   0.000062

count  total (s)   self (s)
    3   0.000100   0.000061     echo s:Ellipsis(a:message)

FUNCTION  <SNR>26_LocalBrowse()
    Defined: /usr/share/nvim/runtime/plugin/netrwPlugin.vim line 102
Called 12 times
Total time:   0.000833
 Self time:   0.000833

count  total (s)   self (s)
                              " Unfortunate interaction -- only DechoMsg debugging calls can be safely used here.
                              " Otherwise, the BufEnter event gets triggered when attempts to write to
                              " the DBG buffer are made.
                            
   12              0.000063   if !exists("s:vimentered")
                               " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
                               " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
                            "   call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered doesn't exist)")
                            "   call Dret("s:LocalBrowse")
                               return
   12              0.000013   endif
                            
                            "  call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered=".s:vimentered.")")
                            
   12              0.000078   if has("amiga")
                               " The check against '' is made for the Amiga, where the empty
                               " string is the current directory and not checking would break
                               " things such as the help command.
                            "   call Decho("(LocalBrowse) dirname<".a:dirname.">  (isdirectory, amiga)")
                               if a:dirname != '' && isdirectory(a:dirname)
                                sil! call netrw#LocalBrowseCheck(a:dirname)
                                if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                 exe w:netrw_bannercnt
                                endif
                               endif
                            
   12              0.000133   elseif isdirectory(a:dirname)
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> ft=".&ft."  (isdirectory, not amiga)")
                            "   call Dredir("LocalBrowse ft last set: ","verbose set ft")
                               sil! call netrw#LocalBrowseCheck(a:dirname)
                               if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                exe w:netrw_bannercnt
                               endif
                            
   12              0.000011   else
                               " not a directory, ignore it
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> not a directory, ignoring...")
   12              0.000012   endif
                            
                            "  call Dret("s:LocalBrowse")

FUNCTION  LSP#viewport()
    Defined: ~/.system/config/nvim/plugged/LanguageClient-neovim/autoload/LSP.vim line 47
Called 354 times
Total time:   0.002299
 Self time:   0.002299

count  total (s)   self (s)
  354              0.002139     return { 'start': line('w0') - 1, 'end': line('w$'), }

FUNCTION  7()
    Defined: ~/.system/config/nvim/plugged/fzf/plugin/fzf.vim line 392
Called 1 time
Total time:   0.006042
 Self time:   0.000007

count  total (s)   self (s)
    1   0.006041   0.000007       return s:common_sink(self._action, a:lines)

FUNCTION  8()
    Defined: ~/.system/config/nvim/plugged/fzf/plugin/fzf.vim line 776
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000002     if a:inplace && bufnr('') == self.buf
                                  if bufexists(self.pbuf)
                                    execute 'keepalt b' self.pbuf
                                  endif
                                  " No other listed buffer
                                  if bufnr('') == self.buf
                                    enew
                                  endif
    1              0.000000     endif

FUNCTION  9()
    Defined: ~/.system/config/nvim/plugged/fzf/plugin/fzf.vim line 787
Called 1 time
Total time:   0.007187
 Self time:   0.000573

count  total (s)   self (s)
    1   0.000031   0.000018     if s:getpos() == self.ppos " {'window': 'enew'}
                                  for [opt, val] in items(self.winopts)
                                    execute 'let' opt '=' val
                                  endfor
                                  call self.switch_back(1)
    1              0.000001     else
    1              0.000012       if bufnr('') == self.buf
                                    " We use close instead of bd! since Vim does not close the split when
                                    " there's no other listed buffer (nvim +'set nobuflisted')
    1   0.000821   0.000474         close
    1              0.000000       endif
    1              0.000004       silent! execute 'tabnext' self.ppos.tab
    1              0.000003       silent! execute self.ppos.win.'wincmd w'
    1              0.000000     endif
                            
    1              0.000001     if bufexists(self.buf)
                                  execute 'bd!' self.buf
    1              0.000000     endif
                            
    1   0.000012   0.000007     if &lines == self.lines && &columns == self.columns && s:getpos() == self.ppos
    1              0.000003       execute self.winrest
    1              0.000000     endif
                            
    1   0.000049   0.000006     let lines = s:collect(self.temps)
    1   0.000018   0.000007     if !s:exit_handler(a:code, self.command, 1)
                                  return
    1              0.000000     endif
                            
    1   0.000065   0.000004     call s:pushd(self.dict)
    1   0.006131   0.000007     call s:callback(self.dict, lines)
    1   0.000020   0.000008     call self.switch_back(s:getpos() == self.ppos)

FUNCTION  <SNR>8_LoadFTPlugin()
    Defined: /usr/share/nvim/runtime/ftplugin.vim line 14
Called 4 times
Total time:   0.003201
 Self time:   0.002028

count  total (s)   self (s)
    4              0.000011     if exists("b:undo_ftplugin")
                                  exe b:undo_ftplugin
                                  unlet! b:undo_ftplugin b:did_ftplugin
    4              0.000002     endif
                            
    4              0.000010     let s = expand("<amatch>")
    4              0.000004     if s != ""
    4              0.000033       if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
    4              0.000002       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
    8              0.000027       for name in split(s, '\.')
    4   0.003066   0.001893 	exe 'runtime! ftplugin/' . name . '.vim ftplugin/' . name . '_*.vim ftplugin/' . name . '/*.vim'
    8              0.000008       endfor
    4              0.000002     endif

FUNCTION  <SNR>17_fzf_tempname()
    Defined: ~/.system/config/nvim/plugged/fzf/plugin/fzf.vim line 114
Called 2 times
Total time:   0.000034
 Self time:   0.000020

count  total (s)   self (s)
    2   0.000033   0.000019   return s:fzf_call('tempname')

FUNCTION  <SNR>36_command()
    Defined: ~/.system/config/nvim/plugged/LanguageClient-neovim/autoload/LanguageClient.vim line 192
Called 2 times
Total time:   0.000026
 Self time:   0.000026

count  total (s)   self (s)
    4              0.000007     for l:cmd in a:000
    2              0.000012         execute l:cmd
    4              0.000003     endfor

FUNCTION  LSP#position()
    Defined: ~/.system/config/nvim/plugged/LanguageClient-neovim/autoload/LSP.vim line 54
Called 276 times
Total time:   0.007929
 Self time:   0.002379

count  total (s)   self (s)
  276   0.007797   0.002246   return s:get_position()

FUNCTION  <SNR>17_open()
    Defined: ~/.system/config/nvim/plugged/fzf/plugin/fzf.vim line 257
Called 2 times
Total time:   0.013450
 Self time:   0.004244

count  total (s)   self (s)
    2   0.000087   0.000024   if stridx('edit', a:cmd) == 0 && s:fzf_fnamemodify(a:target, ':p') ==# s:fzf_expand('%:p')
                                return
    2              0.000001   endif
    2   0.013360   0.004216   execute a:cmd s:escape(a:target)

FUNCTION  <SNR>17_fzf_call()
    Defined: ~/.system/config/nvim/plugged/fzf/plugin/fzf.vim line 73
Called 30 times
Total time:   0.000195
 Self time:   0.000195

count  total (s)   self (s)
   30              0.000181     return call(a:fn, a:000)

FUNCTION  <SNR>17_callback()
    Defined: ~/.system/config/nvim/plugged/fzf/plugin/fzf.vim line 871
Called 2 times
Total time:   0.013851
 Self time:   0.000079

count  total (s)   self (s)
    2              0.000004   let popd = has_key(a:dict, 'pushd')
    2              0.000001   if popd
    2              0.000002     let w:fzf_pushd = a:dict.pushd
    2              0.000001   endif
                            
    2              0.000001   try
    2              0.000002     if has_key(a:dict, 'sink')
                                  for line in a:lines
                                    if type(a:dict.sink) == 2
                                      call a:dict.sink(line)
                                    else
                                      execute a:dict.sink s:escape(line)
                                    endif
                                  endfor
    2              0.000001     endif
    2              0.000003     if has_key(a:dict, 'sink*')
    2   0.013694   0.000010       call a:dict['sink*'](a:lines)
    2              0.000001     endif
                              catch
                                if stridx(v:exception, ':E325:') < 0
                                  echoerr v:exception
                                endif
    2              0.000001   endtry
                            
                              " We may have opened a new window or tab
    2              0.000001   if popd
    2              0.000003     let w:fzf_pushd = a:dict.pushd
    2   0.000100   0.000012     call s:dopopd()
    2              0.000001   endif

FUNCTION  <SNR>36_set_virtual_texts()
    Defined: ~/.system/config/nvim/plugged/LanguageClient-neovim/autoload/LanguageClient.vim line 161
Called 322 times
Total time:   0.014762
 Self time:   0.010687

count  total (s)   self (s)
                                " VirtualText: map with keys line, text and hl_group.
                            
  322   0.006334   0.002259     let l:prefix = s:GetVar('LanguageClient_virtualTextPrefix')
  322              0.000443     if l:prefix is v:null
  322              0.000300         let l:prefix = ''
  322              0.000145     endif
                            
  322              0.000752     if !exists('*nvim_buf_set_virtual_text')
                                    return
  322              0.000129     endif
                            
  322              0.001532     call nvim_buf_clear_namespace(a:buf_id, a:ns_id, a:line_start, a:line_end)
                            
  450              0.000639     for vt in a:virtual_texts
  128              0.001910         call nvim_buf_set_virtual_text(a:buf_id, a:ns_id, vt['line'], [[l:prefix . vt['text'], vt['hl_group']]], {})
  450              0.000312     endfor

FUNCTION  LanguageClient#Notify()
    Defined: ~/.system/config/nvim/plugged/LanguageClient-neovim/autoload/LanguageClient.vim line 759
Called 318 times
Total time:   0.029568
 Self time:   0.016647

count  total (s)   self (s)
  318   0.007313   0.002434     if s:SkipSendingMessage()
                                    " call s:Debug('Skip sending message')
    2              0.000001         return
  316              0.000169     endif
                            
  316              0.000701     let l:params = a:params
  316              0.001128     if type(params) == s:TYPE.dict
  316              0.003165         let l:params = extend({ 'bufnr': bufnr(''), 'languageId': &filetype, }, l:params)
  316              0.000195     endif
  316   0.015835   0.007793     return LanguageClient#Write(json_encode({ 'jsonrpc': '2.0', 'method': a:method, 'params': l:params, }))

FUNCTION  fzf#exec()
    Defined: ~/.system/config/nvim/plugged/fzf/plugin/fzf.vim line 170
Called 4 times
Total time:   0.000258
 Self time:   0.000258

count  total (s)   self (s)
    4              0.000015   if !exists('s:exec')
                                if executable(s:fzf_go)
                                  let s:exec = s:fzf_go
                                elseif executable('fzf')
                                  let s:exec = 'fzf'
                                elseif input('fzf executable not found. Download binary? (y/n) ') =~? '^y'
                                  redraw
                                  call fzf#install()
                                  return fzf#exec()
                                else
                                  redraw
                                  throw 'fzf executable not found'
                                endif
    4              0.000003   endif
                            
    4              0.000016   if a:0 && !has_key(s:checked, a:1)
                                let command = s:exec . ' --version'
                                let output = systemlist(command)
                                if v:shell_error || empty(output)
                                  throw printf('Failed to run "%s": %s', command, output)
                                endif
                                let fzf_version = matchstr(output[-1], '[0-9.]\+')
                                if s:version_requirement(fzf_version, a:1)
                                  let s:checked[a:1] = 1
                                  return s:exec
                                elseif a:0 < 2 && input(printf('You need fzf %s or above. Found: %s. Download binary? (y/n) ', a:1, fzf_version)) =~? '^y'
                                  redraw
                                  call fzf#install()
                                  return fzf#exec(a:1, 1)
                                else
                                  throw printf('You need to upgrade fzf (required: %s or above)', a:1)
                                endif
    4              0.000003   endif
                            
    4              0.000007   return s:exec

FUNCTION  <SNR>36_Ellipsis()
    Defined: ~/.system/config/nvim/plugged/LanguageClient-neovim/autoload/LanguageClient.vim line 22
Called 3 times
Total time:   0.000039
 Self time:   0.000039

count  total (s)   self (s)
    3              0.000007     let l:maxlen = &columns * &cmdheight - 2
    3              0.000003     if &showcmd
    3              0.000003         let maxlen -= 11
    3              0.000001     endif
    3              0.000002     if &ruler
    3              0.000002         let maxlen -= 18
    3              0.000001     endif
    3              0.000004     if len(a:message) < l:maxlen
    3              0.000003         let l:message = a:message
                                else
                                    let l:message = a:message[:l:maxlen - 3] . '...'
    3              0.000001     endif
    3              0.000003     return l:message

FUNCTION  <SNR>17_shortpath()
    Defined: ~/.system/config/nvim/plugged/fzf/plugin/fzf.vim line 954
Called 2 times
Total time:   0.000132
 Self time:   0.000132

count  total (s)   self (s)
    2              0.000043   let short = fnamemodify(getcwd(), ':~:.')
    2              0.000019   if !has('win32unix')
    2              0.000009     let short = pathshorten(short)
    2              0.000002   endif
    2              0.000008   let slash = (s:is_win && !&shellslash) ? '\' : '/'
    2              0.000044   return empty(short) ? '~'.slash : short . (short =~ escape(slash, '\').'$' ? '' : slash)

FUNCTION  <SNR>17_popup()
    Defined: ~/.system/config/nvim/plugged/fzf/plugin/fzf.vim line 931
Called 2 times
Total time:   0.001605
 Self time:   0.000177

count  total (s)   self (s)
                              " Size and position
    2              0.000027   let width = min([max([8, a:opts.width > 1 ? a:opts.width : float2nr(&columns * a:opts.width)]), &columns])
    2              0.000024   let height = min([max([4, a:opts.height > 1 ? a:opts.height : float2nr(&lines * a:opts.height)]), &lines - has('nvim')])
    2              0.000017   let row = float2nr(get(a:opts, 'yoffset', 0.5) * (&lines - height))
    2              0.000011   let col = float2nr(get(a:opts, 'xoffset', 0.5) * (&columns - width))
                            
                              " Managing the differences
    2              0.000018   let row = min([max([0, row]), &lines - has('nvim') - height])
    2              0.000011   let col = min([max([0, col]), &columns - width])
    2              0.000009   let row += !has('nvim')
    2              0.000007   let col += !has('nvim')
                            
    2   0.001470   0.000043   call s:create_popup('Normal', { 'row': row, 'col': col, 'width': width, 'height': height })

FUNCTION  <SNR>36_HandleMessage()
    Defined: ~/.system/config/nvim/plugged/LanguageClient-neovim/autoload/LanguageClient.vim line 505
Called 1274 times
Total time:   0.361673
 Self time:   0.316118

count  total (s)   self (s)
 1274              0.003998     if a:event ==# 'stdout'
 6751              0.010371         while len(a:lines) > 0
 5477              0.010563             let l:line = remove(a:lines, 0)
                            
 5477              0.005592             if l:line ==# ''
 2675              0.001684                 continue
 2802              0.003026             elseif s:content_length == 0
 1401              0.015012                 let s:content_length = str2nr(substitute(l:line, '.*Content-Length:', '', ''))
 1401              0.001263                 continue
 1401              0.000645             endif
                            
 1401              0.005412             let s:input .= strpart(l:line, 0, s:content_length)
 1401              0.002551             if s:content_length < strlen(l:line)
                                            call insert(a:lines, strpart(l:line, s:content_length), 0)
                                            let s:content_length = 0
 1401              0.000647             else
 1401              0.003119                 let s:content_length = s:content_length - strlen(l:line)
 1401              0.000614             endif
 1401              0.001141             if s:content_length > 0
                                            continue
 1401              0.000486             endif
                            
 1401              0.000843             try
 1401              0.008399                 let l:message = json_decode(s:input)
 1401              0.003050                 if type(l:message) !=# s:TYPE.dict
                                                throw 'Messsage is not dict.'
 1401              0.000551                 endif
                                        catch
                                            call s:Debug('Error decoding message: ' . string(v:exception) . ' Message: ' . s:input)
                                            continue
 1401              0.001072             finally
 1401              0.001743                 let s:input = ''
 1401              0.000893             endtry
                            
 1401              0.002443             if has_key(l:message, 'method')
 1401              0.003322                 let l:id = get(l:message, 'id', v:null)
 1401              0.002762                 let l:method = get(l:message, 'method')
 1401              0.002249                 let l:params = get(l:message, 'params')
 1401              0.000630                 try
 1401              0.004062                     let l:params = type(l:params) == s:TYPE.list ? l:params : [l:params]
 1401   0.035829   0.010496                     let l:result = call(l:method, l:params)
 1401              0.001704                     if l:id isnot v:null
 1262   0.051938   0.031716                         call LanguageClient#Write(json_encode({ 'jsonrpc': '2.0', 'id': l:id, 'result': l:result, }))
 1401              0.000812                     endif
                                            catch
                                                let l:exception = v:exception
                                                if l:id isnot v:null
                                                    try
                                                        call LanguageClient#Write(json_encode({ 'jsonrpc': '2.0', 'id': l:id, 'error': {   'code': -32603,   'message': string(v:exception)   } }))
                                                    catch
                                                        " TODO
                                                    endtry
                                                endif
                                                call s:Debug(string(l:exception))
 1401              0.000722                 endtry
                                        elseif has_key(l:message, 'result') || has_key(l:message, 'error')
                                            let l:id = get(l:message, 'id')
                                            let l:Handle = get(s:handlers, l:id)
                                            unlet s:handlers[l:id]
                                            let l:type = type(l:Handle)
                                            if l:type == s:TYPE.funcref || l:type == s:TYPE.string
                                                call call(l:Handle, [l:message])
                                            elseif l:type == s:TYPE.list
                                                call add(l:Handle, l:message)
                                            elseif l:type == s:TYPE.string && exists(l:Handle)
                                                let l:outputs = eval(l:Handle)
                                                call add(l:outputs, l:message)
                                            else
                                                call s:Echoerr('Unknown Handle type: ' . string(l:Handle))
                                            endif
                                        else
                                            call s:Echoerr('Unknown message: ' . string(l:message))
 1401              0.000539             endif
 2675              0.003927         endwhile
                                elseif a:event ==# 'stderr'
                                    call s:Echoerr('LanguageClient stderr: ' . string(a:lines))
                                elseif a:event ==# 'exit'
                                    if type(a:lines) == type(0) && (a:lines == 0 || a:lines == 143)
                                        return
                                    endif
                                    call s:Debug('LanguageClient exited with: ' . string(a:lines))
                                else
                                    call s:Debug('LanguageClient unknown event: ' . a:event)
 1274              0.000627     endif

FUNCTION  <SNR>36_set_signs()
    Defined: ~/.system/config/nvim/plugged/LanguageClient-neovim/autoload/LanguageClient.vim line 180
Called 266 times
Total time:   0.003323
 Self time:   0.003323

count  total (s)   self (s)
                                " TODO: Optimize to update sign instead of add + remove sign.
  267              0.000643     for l:sign in a:signs_to_add
    1              0.000001         let l:line = l:sign['line'] + 1
    1              0.000015         execute ':sign place ' . l:sign['id'] . ' line=' . l:line . ' name=' . l:sign['name'] . ' file=' . a:file
  267              0.000280     endfor
  267              0.000411     for l:sign in a:signs_to_delete
    1              0.000004         execute ':sign unplace ' . l:sign['id']
  267              0.000165     endfor

FUNCTION  11()
    Defined: ~/.system/config/nvim/plugged/fzf/plugin/fzf.vim line 776
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000002     if a:inplace && bufnr('') == self.buf
                                  if bufexists(self.pbuf)
                                    execute 'keepalt b' self.pbuf
                                  endif
                                  " No other listed buffer
                                  if bufnr('') == self.buf
                                    enew
                                  endif
    1              0.000000     endif

FUNCTION  12()
    Defined: ~/.system/config/nvim/plugged/fzf/plugin/fzf.vim line 787
Called 1 time
Total time:   0.009506
 Self time:   0.000840

count  total (s)   self (s)
    1   0.000053   0.000033     if s:getpos() == self.ppos " {'window': 'enew'}
                                  for [opt, val] in items(self.winopts)
                                    execute 'let' opt '=' val
                                  endfor
                                  call self.switch_back(1)
    1              0.000001     else
    1              0.000004       if bufnr('') == self.buf
                                    " We use close instead of bd! since Vim does not close the split when
                                    " there's no other listed buffer (nvim +'set nobuflisted')
    1   0.001335   0.000681         close
    1              0.000001       endif
    1              0.000008       silent! execute 'tabnext' self.ppos.tab
    1              0.000006       silent! execute self.ppos.win.'wincmd w'
    1              0.000001     endif
                            
    1              0.000003     if bufexists(self.buf)
                                  execute 'bd!' self.buf
    1              0.000001     endif
                            
    1   0.000025   0.000015     if &lines == self.lines && &columns == self.columns && s:getpos() == self.ppos
    1              0.000007       execute self.winrest
    1              0.000001     endif
                            
    1   0.000095   0.000012     let lines = s:collect(self.temps)
    1   0.000037   0.000014     if !s:exit_handler(a:code, self.command, 1)
                                  return
    1              0.000001     endif
                            
    1   0.000146   0.000008     call s:pushd(self.dict)
    1   0.007735   0.000008     call s:callback(self.dict, lines)
    1   0.000019   0.000008     call self.switch_back(s:getpos() == self.ppos)

FUNCTION  <SNR>17_defaults()
    Defined: ~/.system/config/nvim/plugged/fzf/plugin/fzf.vim line 319
Called 2 times
Total time:   0.000054
 Self time:   0.000054

count  total (s)   self (s)
    2              0.000013   let rules = copy(get(g:, 'fzf_colors', {}))
    2              0.000027   let colors = join(map(items(filter(map(rules, 'call("s:get_color", v:val)'), '!empty(v:val)')), 'join(v:val, ":")'), ',')
    2              0.000011   return empty(colors) ? '' : fzf#shellescape('--color='.colors)

FUNCTION  <SNR>17_default_layout()
    Defined: ~/.system/config/nvim/plugged/fzf/plugin/fzf.vim line 129
Called 2 times
Total time:   0.000071
 Self time:   0.000046

count  total (s)   self (s)
    2   0.000069   0.000044   return s:popup_support() ? { 'window' : { 'width': 0.9, 'height': 0.6 } } : { 'down': '~40%' }

FUNCTION  <SNR>18_fzf_restore_colors()
    Defined: ~/.system/config/nvim/plugged/fzf.vim/plugin/fzf.vim line 95
Called 2 times
Total time:   0.000048
 Self time:   0.000048

count  total (s)   self (s)
    2              0.000004     if exists('#User#FzfStatusLine')
                                  doautocmd User FzfStatusLine
    2              0.000001     else
    2              0.000010       if $TERM !~ "256color"
                                    highlight default fzf1 ctermfg=1 ctermbg=8 guifg=#E12672 guibg=#565656
                                    highlight default fzf2 ctermfg=2 ctermbg=8 guifg=#BCDDBD guibg=#565656
                                    highlight default fzf3 ctermfg=7 ctermbg=8 guifg=#D9D9D9 guibg=#565656
    2              0.000001       else
    2              0.000008         highlight default fzf1 ctermfg=161 ctermbg=238 guifg=#E12672 guibg=#565656
    2              0.000002         highlight default fzf2 ctermfg=151 ctermbg=238 guifg=#BCDDBD guibg=#565656
    2              0.000002         highlight default fzf3 ctermfg=252 ctermbg=238 guifg=#D9D9D9 guibg=#565656
    2              0.000001       endif
    2              0.000009       setlocal statusline=%#fzf1#\ >\ %#fzf2#fz%#fzf3#f
    2              0.000001     endif

FUNCTION  LanguageClient#handleCursorMoved()
    Defined: ~/.system/config/nvim/plugged/LanguageClient-neovim/autoload/LanguageClient.vim line 1193
Called 338 times
Total time:   0.070965
 Self time:   0.021729

count  total (s)   self (s)
  338              0.004146     let l:cursor_line = getcurpos()[1] - 1
  338              0.001339     if l:cursor_line == s:last_cursor_line
   90              0.000074         return
  248              0.000337     endif
  248              0.000870     let s:last_cursor_line = l:cursor_line
                            
  248              0.000481     try
  248   0.060425   0.011189         call LanguageClient#Notify('languageClient/handleCursorMoved', { 'buftype': &buftype, 'filename': LSP#filename(), 'position': LSP#position(), 'viewport': LSP#viewport(), })
                                catch
                                    call s:Debug('LanguageClient caught exception: ' . string(v:exception))
  248              0.000302     endtry

FUNCTION  <SNR>9_LoadIndent()
    Defined: /usr/share/nvim/runtime/indent.vim line 13
Called 4 times
Total time:   0.000432
 Self time:   0.000388

count  total (s)   self (s)
    4              0.000009     if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
    4              0.000002     endif
    4              0.000009     let s = expand("<amatch>")
    4              0.000004     if s != ""
    4              0.000005       if exists("b:did_indent")
                            	unlet b:did_indent
    4              0.000002       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
    8              0.000019       for name in split(s, '\.')
    4   0.000351   0.000307 	exe 'runtime! indent/' . name . '.vim'
    8              0.000005       endfor
    4              0.000002     endif

FUNCTION  <SNR>17_collect()
    Defined: ~/.system/config/nvim/plugged/fzf/plugin/fzf.vim line 861
Called 2 times
Total time:   0.000126
 Self time:   0.000126

count  total (s)   self (s)
    2              0.000002   try
    2              0.000064     return filereadable(a:temps.result) ? readfile(a:temps.result) : []
    2              0.000003   finally
    4              0.000011     for tf in values(a:temps)
    2              0.000032       silent! call delete(tf)
    4              0.000004     endfor
    2              0.000002   endtry

FUNCTION  <SNR>17_escape()
    Defined: ~/.system/config/nvim/plugged/fzf/plugin/fzf.vim line 231
Called 10 times
Total time:   0.000072
 Self time:   0.000072

count  total (s)   self (s)
   10              0.000035   let path = fnameescape(a:path)
   10              0.000031   return s:is_win ? escape(path, '$') : path

FUNCTION  <SNR>17_use_sh()
    Defined: ~/.system/config/nvim/plugged/fzf/plugin/fzf.vim line 401
Called 4 times
Total time:   0.000149
 Self time:   0.000149

count  total (s)   self (s)
    4              0.000047   let [shell, shellslash, shellcmdflag, shellxquote] = [&shell, &shellslash, &shellcmdflag, &shellxquote]
    4              0.000007   if s:is_win
                                set shell=cmd.exe
                                set noshellslash
                                let &shellcmdflag = has('nvim') ? '/s /c' : '/c'
                                let &shellxquote = has('nvim') ? '"' : '('
    4              0.000004   else
    4              0.000029     set shell=sh
    4              0.000004   endif
    4              0.000018   return [shell, shellslash, shellcmdflag, shellxquote]

FUNCTION  LanguageClient#Write()
    Defined: ~/.system/config/nvim/plugged/LanguageClient-neovim/autoload/LanguageClient.vim line 709
Called 1578 times
Total time:   0.028265
 Self time:   0.028265

count  total (s)   self (s)
 1578              0.004203     let l:message = a:message . "\n"
 1578              0.004703     if has('nvim')
                                    " jobsend respond 1 for success.
 1578              0.017558         return !jobsend(s:job, l:message)
                                elseif has('channel')
                                    return ch_sendraw(s:job, l:message)
                                else
                                    echoerr 'Not supported: not nvim nor vim with +channel.'
                                endif

FUNCTION  LanguageClient#handleFileType()
    Defined: ~/.system/config/nvim/plugged/LanguageClient-neovim/autoload/LanguageClient.vim line 1141
Called 4 times
Total time:   0.000515
 Self time:   0.000128

count  total (s)   self (s)
    4              0.000003     try
    4   0.000091   0.000032         if s:Debounce(2, 'LanguageClient#handleFileType')
    4   0.000401   0.000073             call LanguageClient#Notify('languageClient/handleFileType', { 'filename': LSP#filename(), 'position': LSP#position(), 'viewport': LSP#viewport(), })
    4              0.000002         endif
                                catch
                                    call s:Debug('LanguageClient caught exception: ' . string(v:exception))
    4              0.000002     endtry

FUNCTION  <SNR>17_create_popup()
    Defined: ~/.system/config/nvim/plugged/fzf/plugin/fzf.vim line 904
Called 2 times
Total time:   0.001428
 Self time:   0.000747

count  total (s)   self (s)
    2              0.000420     let buf = nvim_create_buf(v:false, v:true)
    2              0.000036     let opts = extend({'relative': 'editor', 'style': 'minimal'}, a:opts)
    2              0.000014     let border = has_key(opts, 'border') ? remove(opts, 'border') : []
    2   0.000844   0.000163     let win = nvim_open_win(buf, v:true, opts)
    2              0.000074     call setwinvar(win, '&winhighlight', 'NormalFloat:'..a:hl)
    2              0.000013     call setwinvar(win, '&colorcolumn', '')
    2              0.000006     if !empty(border)
                                  call nvim_buf_set_lines(buf, 0, -1, v:true, border)
    2              0.000002     endif
    2              0.000004     return buf

FUNCTION  <SNR>36_SkipSendingMessage()
    Defined: ~/.system/config/nvim/plugged/LanguageClient-neovim/autoload/LanguageClient.vim line 721
Called 318 times
Total time:   0.004879
 Self time:   0.004879

count  total (s)   self (s)
  318              0.002153     if expand('%') =~# '^jdt://'
                                    return v:false
  318              0.000224     endif
                            
  318              0.001575     return &buftype !=# '' || &filetype ==# '' || expand('%') ==# ''

FUNCTION  <SNR>17_execute_term()
    Defined: ~/.system/config/nvim/plugged/fzf/plugin/fzf.vim line 767
Called 2 times
Total time:   0.007656
 Self time:   0.003189

count  total (s)   self (s)
    2              0.000012   let winrest = winrestcmd()
    2              0.000008   let pbuf = bufnr('')
    2   0.001993   0.000035   let [ppos, winopts, is_popup] = s:split(a:dict)
    2   0.000099   0.000032   call s:use_sh()
    2              0.000006   let b:fzf = a:dict
    2              0.000032   let fzf = { 'buf': bufnr(''), 'pbuf': pbuf, 'ppos': ppos, 'dict': a:dict, 'temps': a:temps, 'winopts': winopts, 'winrest': winrest, 'lines': &lines, 'columns': &columns, 'command': a:command }
    2              0.000009   function! fzf.switch_back(inplace)
                                if a:inplace && bufnr('') == self.buf
                                  if bufexists(self.pbuf)
                                    execute 'keepalt b' self.pbuf
                                  endif
                                  " No other listed buffer
                                  if bufnr('') == self.buf
                                    enew
                                  endif
                                endif
                              endfunction
    2              0.000005   function! fzf.on_exit(id, code, ...)
                                if s:getpos() == self.ppos " {'window': 'enew'}
                                  for [opt, val] in items(self.winopts)
                                    execute 'let' opt '=' val
                                  endfor
                                  call self.switch_back(1)
                                else
                                  if bufnr('') == self.buf
                                    " We use close instead of bd! since Vim does not close the split when
                                    " there's no other listed buffer (nvim +'set nobuflisted')
                                    close
                                  endif
                                  silent! execute 'tabnext' self.ppos.tab
                                  silent! execute self.ppos.win.'wincmd w'
                                endif
                            
                                if bufexists(self.buf)
                                  execute 'bd!' self.buf
                                endif
                            
                                if &lines == self.lines && &columns == self.columns && s:getpos() == self.ppos
                                  execute self.winrest
                                endif
                            
                                let lines = s:collect(self.temps)
                                if !s:exit_handler(a:code, self.command, 1)
                                  return
                                endif
                            
                                call s:pushd(self.dict)
                                call s:callback(self.dict, lines)
                                call self.switch_back(s:getpos() == self.ppos)
                              endfunction
                            
    2              0.000003   try
    2   0.000343   0.000024     call s:pushd(a:dict)
    2              0.000003     if s:is_win
                                  let fzf.temps.batchfile = s:fzf_tempname().'.bat'
                                  call writefile(s:wrap_cmds(a:command), fzf.temps.batchfile)
                                  let command = fzf.temps.batchfile
    2              0.000002     else
    2              0.000006       let command = a:command
    2              0.000002     endif
    2              0.000009     let command .= s:term_marker
    2              0.000010     if has('nvim')
    2              0.002763       call termopen(command, fzf)
                                else
                                  let term_opts = {'exit_cb': function(fzf.on_exit)}
                                  if is_popup
                                    let term_opts.hidden = 1
                                  else
                                    let term_opts.curwin = 1
                                  endif
                                  let fzf.buf = term_start([&shell, &shellcmdflag, command], term_opts)
                                  if exists('&termwinkey')
                                    call setbufvar(fzf.buf, '&termwinkey', '<c-z>')
                                  endif
                                  if is_popup && exists('#TerminalWinOpen')
                                    doautocmd <nomodeline> TerminalWinOpen
                                  endif
                                  if !has('patch-8.0.1261') && !s:is_win
                                    call term_wait(fzf.buf, 20)
                                  endif
    2              0.000001     endif
    2              0.000026     tnoremap <buffer> <c-z> <nop>
    2              0.000002   finally
    2   0.000184   0.000033     call s:dopopd()
    2              0.000001   endtry
    2              0.000015   setlocal nospell bufhidden=wipe nobuflisted nonumber
    2   0.001983   0.000012   setf fzf
    2              0.000002   startinsert
    2              0.000004   return []

FUNCTION  <SNR>36_Debounce()
    Defined: ~/.system/config/nvim/plugged/LanguageClient-neovim/autoload/LanguageClient.vim line 85
Called 4 times
Total time:   0.000059
 Self time:   0.000059

count  total (s)   self (s)
                                " Map function to its last execute time.
    4              0.000017     let s:DebounceMap = {}
    4              0.000010     let l:lastexectime = get(s:DebounceMap, a:f)
    4              0.000010     if l:lastexectime == 0 || reltimefloat(reltime(l:lastexectime)) < a:timeout
    4              0.000011         let s:DebounceMap[a:f] = reltime()
    4              0.000004         return v:true
                                else
                                    return v:false
                                endif

FUNCTION  <SNR>17_getpos()
    Defined: ~/.system/config/nvim/plugged/fzf/plugin/fzf.vim line 692
Called 8 times
Total time:   0.000084
 Self time:   0.000084

count  total (s)   self (s)
    8              0.000079   return {'tab': tabpagenr(), 'win': winnr(), 'winid': win_getid(), 'cnt': winnr('$'), 'tcnt': tabpagenr('$')}

FUNCTION  LSP#line()
    Defined: ~/.system/config/nvim/plugged/LanguageClient-neovim/autoload/LSP.vim line 26
Called 276 times
Total time:   0.000975
 Self time:   0.000975

count  total (s)   self (s)
  276              0.000825     return line('.') - 1

FUNCTION  LSP#text()
    Defined: ~/.system/config/nvim/plugged/LanguageClient-neovim/autoload/LSP.vim line 16
Called 56 times
Total time:   0.004587
 Self time:   0.004587

count  total (s)   self (s)
   56              0.000128     let l:buf = get(a:000, 0, '')
                            
   56              0.004038     let l:lines = getbufline(l:buf, 1, '$')
   56              0.000178     if len(l:lines) > 0 && l:lines[-1] !=# '' && &fixendofline
   56              0.000096         let l:lines += ['']
   56              0.000021     endif
   56              0.000047     return l:lines

FUNCTION  LSP#character()
    Defined: ~/.system/config/nvim/plugged/LanguageClient-neovim/autoload/LSP.vim line 30
Called 276 times
Total time:   0.000759
 Self time:   0.000759

count  total (s)   self (s)
  276              0.000679     return col('.') - 1

FUNCTION  <SNR>17_common_sink()
    Defined: ~/.system/config/nvim/plugged/fzf/plugin/fzf.vim line 264
Called 2 times
Total time:   0.013669
 Self time:   0.000199

count  total (s)   self (s)
    2              0.000003   if len(a:lines) < 2
                                return
    2              0.000001   endif
    2              0.000004   let key = remove(a:lines, 0)
    2              0.000004   let Cmd = get(a:action, key, 'e')
    2              0.000007   if type(Cmd) == type(function('call'))
                                return Cmd(a:lines)
    2              0.000001   endif
    2              0.000002   if len(a:lines) > 1
                                augroup fzf_swap
                                  autocmd SwapExists * let v:swapchoice='o'| call s:warn('fzf: E325: swap file exists: '.s:fzf_expand('<afile>'))
                                augroup END
    2              0.000001   endif
    2              0.000001   try
    2   0.000035   0.000015     let empty = empty(s:fzf_expand('%')) && line('$') == 1 && empty(getline(1)) && !&modified
                                " Preserve the current working directory in case it's changed during
                                " the execution (e.g. `set autochdir` or `autocmd BufEnter * lcd ...`)
    2              0.000006     let cwd = exists('w:fzf_pushd') ? w:fzf_pushd.dir : expand('%:p:h')
    4              0.000005     for item in a:lines
    2              0.000011       if item[0] != '~' && item !~ (s:is_win ? '^[A-Z]:\' : '^/')
    2              0.000003         let sep = s:is_win ? '\' : '/'
    2              0.000012         let item = join([cwd, item], cwd[len(cwd)-1] == sep ? '' : sep)
    2              0.000001       endif
    2              0.000001       if empty
                                    execute 'e' s:escape(item)
                                    let empty = 0
    2              0.000001       else
    2   0.013470   0.000020         call s:open(Cmd, item)
    2              0.000002       endif
    2              0.000010       if !has('patch-8.0.0177') && !has('nvim-0.2') && exists('#BufEnter') && isdirectory(item)
                                    doautocmd BufEnter
    2              0.000001       endif
    4              0.000002     endfor
                              catch /^Vim:Interrupt$/
    2              0.000001   finally
    2              0.000019     silent! autocmd! fzf_swap
    2              0.000011   endtry

FUNCTION  <SNR>17_fzf_expand()
    Defined: ~/.system/config/nvim/plugged/fzf/plugin/fzf.vim line 110
Called 4 times
Total time:   0.000054
 Self time:   0.000023

count  total (s)   self (s)
    4   0.000052   0.000020   return s:fzf_call('expand', a:fmt, 1)

FUNCTION  <SNR>37_get_position()
    Defined: ~/.system/config/nvim/plugged/LanguageClient-neovim/autoload/LSP.vim line 69
Called 276 times
Total time:   0.005550
 Self time:   0.003816

count  total (s)   self (s)
  276   0.005413   0.003678 	return { 'line': LSP#line(), 'character': LSP#character(), }

FUNCTION  LSP#filename()
    Defined: ~/.system/config/nvim/plugged/LanguageClient-neovim/autoload/LSP.vim line 3
Called 390 times
Total time:   0.018509
 Self time:   0.018509

count  total (s)   self (s)
                                " When executing autocommand, `%` might have already changed.
  390              0.010013     let l:filename = expand('<afile>:p')
  390              0.000873     if !l:filename
  390              0.005671         let l:filename = expand('%:p')
  390              0.000326     endif
  390              0.000689     return l:filename

FUNCTION  <SNR>17_pushd()
    Defined: ~/.system/config/nvim/plugged/fzf/plugin/fzf.vim line 519
Called 4 times
Total time:   0.000517
 Self time:   0.000331

count  total (s)   self (s)
    4   0.000079   0.000036   if s:present(a:dict, 'dir')
    4   0.000101   0.000035     let cwd = s:fzf_getcwd()
    4              0.000044     let w:fzf_pushd = {   'command': haslocaldir() ? 'lcd' : (exists(':tcd') && haslocaldir(-1) ? 'tcd' : 'cd'),   'origin': cwd,   'bufname': bufname('') }
    4   0.000172   0.000138     execute 'lcd' s:escape(a:dict.dir)
    4   0.000085   0.000042     let cwd = s:fzf_getcwd()
    4              0.000010     let w:fzf_pushd.dir = cwd
    4              0.000012     let a:dict.pushd = w:fzf_pushd
    4              0.000005     return cwd
                              endif
                              return ''

FUNCTION  fzf#wrap()
    Defined: ~/.system/config/nvim/plugged/fzf/plugin/fzf.vim line 341
Called 2 times
Total time:   0.001250
 Self time:   0.000632

count  total (s)   self (s)
    2              0.000008   let args = ['', {}, 0]
    2              0.000030   let expects = map(copy(args), 'type(v:val)')
    2              0.000004   let tidx = 0
    8              0.000024   for arg in copy(a:000)
    6              0.000047     let tidx = index(expects, type(arg) == 6 ? type(0) : type(arg), tidx)
    6              0.000010     if tidx < 0
                                  throw 'Invalid arguments (expected: [name string] [opts dict] [fullscreen boolean])'
    6              0.000005     endif
    6              0.000018     let args[tidx] = arg
    6              0.000012     let tidx += 1
    6              0.000012     unlet arg
    8              0.000009   endfor
    2              0.000009   let [name, opts, bang] = args
                            
    2              0.000006   if len(name)
    2              0.000007     let opts.name = name
    2              0.000002   end
                            
                              " Layout: g:fzf_layout (and deprecated g:fzf_height)
    2              0.000003   if bang
                                for key in s:layout_keys
                                  if has_key(opts, key)
                                    call remove(opts, key)
                                  endif
                                endfor
    2   0.000133   0.000031   elseif !s:has_any(opts, s:layout_keys)
    2              0.000012     if !exists('g:fzf_layout') && exists('g:fzf_height')
                                  let opts.down = g:fzf_height
    2              0.000002     else
    2   0.000216   0.000083       let opts = extend(opts, s:validate_layout(get(g:, 'fzf_layout', s:default_layout())))
    2              0.000002     endif
    2              0.000002   endif
                            
                              " Colors: g:fzf_colors
    2   0.000385   0.000052   let opts.options = s:defaults() .' '. s:evaluate_opts(get(opts, 'options', ''))
                            
                              " History: g:fzf_history_dir
    2              0.000013   if len(name) && len(get(g:, 'fzf_history_dir', ''))
                                let dir = s:fzf_expand(g:fzf_history_dir)
                                if !isdirectory(dir)
                                  call mkdir(dir, 'p')
                                endif
                                let history = fzf#shellescape(dir.'/'.name)
                                let opts.options = join(['--history', history, opts.options])
    2              0.000002   endif
                            
                              " Action: g:fzf_action
    2   0.000077   0.000027   if !s:has_any(opts, ['sink', 'sink*'])
    2              0.000011     let opts._action = get(g:, 'fzf_action', s:default_action)
    2              0.000020     let opts.options .= ' --expect='.join(keys(opts._action), ',')
    2              0.000009     function! opts.sink(lines) abort
                                  return s:common_sink(self._action, a:lines)
                                endfunction
    2              0.000013     let opts['sink*'] = remove(opts, 'sink')
    2              0.000002   endif
                            
    2              0.000003   return opts

FUNCTION  <SNR>25_Highlight_Matching_Pair()
    Defined: /usr/share/nvim/runtime/plugin/matchparen.vim line 39
Called 449 times
Total time:   0.042251
 Self time:   0.042251

count  total (s)   self (s)
                              " Remove any previous match.
  449              0.001661   if exists('w:paren_hl_on') && w:paren_hl_on
   10              0.000017     silent! call matchdelete(3)
   10              0.000011     let w:paren_hl_on = 0
  449              0.000303   endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
  449              0.001711   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
  449              0.000208   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
  449              0.001062   let c_lnum = line('.')
  449              0.000894   let c_col = col('.')
  449              0.000548   let before = 0
                            
  449              0.001095   let text = getline(c_lnum)
  449              0.006268   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
  449              0.000983   if empty(matches)
                                let [c_before, c] = ['', '']
  449              0.000344   else
  449              0.002269     let [c_before, c] = matches[1:2]
  449              0.000282   endif
  449              0.006079   let plist = split(&matchpairs, '.\zs[:,]')
  449              0.001556   let i = index(plist, c)
  449              0.000579   if i < 0
                                " not found, in Insert mode try character before the cursor
  430              0.001664     if c_col > 1 && (mode() == 'i' || mode() == 'R')
  104              0.000174       let before = strlen(c_before)
  104              0.000100       let c = c_before
  104              0.000143       let i = index(plist, c)
  430              0.000294     endif
  430              0.000456     if i < 0
                                  " not found, nothing to do
  430              0.000463       return
                                endif
   19              0.000006   endif
                            
                              " Figure out the arguments for searchpairpos().
   19              0.000015   if i % 2 == 0
   10              0.000009     let s_flags = 'nW'
   10              0.000016     let c2 = plist[i + 1]
    9              0.000003   else
    9              0.000007     let s_flags = 'nbW'
    9              0.000007     let c2 = c
    9              0.000011     let c = plist[i - 1]
   19              0.000006   endif
   19              0.000014   if c == '['
                                let c = '\['
                                let c2 = '\]'
   19              0.000005   endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
   19              0.000013   if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
   19              0.000005   endif
                            
   19              0.000057   if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
   19              0.000006   else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial.
   19              0.000041     let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
   19              0.000010     try
   19              0.001550       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
   19              0.000009     endtry
   19              0.000006   endif
                            
                              " Limit the search to lines visible in the window.
   19              0.000030   let stoplinebottom = line('w$')
   19              0.000022   let stoplinetop = line('w0')
   19              0.000015   if i % 2 == 0
   10              0.000012     let stopline = stoplinebottom
    9              0.000003   else
    9              0.000010     let stopline = stoplinetop
   19              0.000006   endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
   19              0.000036   if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
   19              0.000005   else
   19              0.000047     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
   19              0.000006   endif
   19              0.000008   try
   19              0.001700     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
   19              0.000008   endtry
                            
   19              0.000014   if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
   19              0.000006   endif
                            
                              " If a match is found setup match highlighting.
   19              0.000028   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
   10              0.000015     if exists('*matchaddpos')
   10              0.000163       call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
   10              0.000003     endif
   10              0.000011     let w:paren_hl_on = 1
   19              0.000006   endif

FUNCTION  <SNR>17_has_any()
    Defined: ~/.system/config/nvim/plugged/fzf/plugin/fzf.vim line 248
Called 4 times
Total time:   0.000152
 Self time:   0.000152

count  total (s)   self (s)
   20              0.000034   for key in a:keys
   16              0.000044     if has_key(a:dict, key)
                                  return 1
   16              0.000010     endif
   20              0.000016   endfor
    4              0.000006   return 0

FUNCTION  <SNR>36_AddHighlights()
    Defined: ~/.system/config/nvim/plugged/LanguageClient-neovim/autoload/LanguageClient.vim line 285
Called 11 times
Total time:   0.000189
 Self time:   0.000189

count  total (s)   self (s)
   24              0.000023     for hl in a:highlights
   13              0.000126         call nvim_buf_add_highlight(0, a:source, hl.group, hl.line, hl.character_start, hl.character_end)
   24              0.000011     endfor

FUNCTION  <SNR>36_GetVar()
    Defined: ~/.system/config/nvim/plugged/LanguageClient-neovim/autoload/LanguageClient.vim line 293
Called 324 times
Total time:   0.004100
 Self time:   0.004100

count  total (s)   self (s)
  324              0.000490     let name = a:1
                            
  324              0.000894     if exists('b:' . name)
                                    return get(b:, name)
  324              0.000620     elseif exists('g:' . name)
                                    return get(g:, name)
  324              0.000145     else
  324              0.000662         return get(a:000, 1, v:null)
                                endif

FUNCTION  fzf#shellescape()
    Defined: ~/.system/config/nvim/plugged/fzf/plugin/fzf.vim line 94
Called 8 times
Total time:   0.000257
 Self time:   0.000208

count  total (s)   self (s)
    8              0.000042   let shell = get(a:000, 0, s:is_win ? 'cmd.exe' : 'sh')
    8              0.000045   if shell =~# 'cmd.exe$'
                                return s:shellesc_cmd(a:arg)
    8              0.000007   endif
    8   0.000133   0.000083   return s:fzf_call('shellescape', a:arg)

FUNCTION  <SNR>17_present()
    Defined: ~/.system/config/nvim/plugged/fzf/plugin/fzf.vim line 485
Called 6 times
Total time:   0.000069
 Self time:   0.000069

count  total (s)   self (s)
    6              0.000022   for key in a:000
    6              0.000032     if !empty(get(a:dict, key, ''))
    6              0.000008       return 1
                                endif
                              endfor
                              return 0

FUNCTION  <SNR>17_split()
    Defined: ~/.system/config/nvim/plugged/fzf/plugin/fzf.vim line 722
Called 2 times
Total time:   0.001958
 Self time:   0.000280

count  total (s)   self (s)
    2              0.000032   let directions = { 'up':    ['topleft', 'resize', &lines], 'down':  ['botright', 'resize', &lines], 'left':  ['vertical topleft', 'vertical resize', &columns], 'right': ['vertical botright', 'vertical resize', &columns] }
    2   0.000047   0.000021   let ppos = s:getpos()
    2              0.000004   let is_popup = 0
    2              0.000003   try
    2   0.000048   0.000022     if s:present(a:dict, 'window')
    2              0.000009       if type(a:dict.window) == type({})
    2   0.000039   0.000018         if !s:popup_support()
                                      throw 'Nvim 0.4+ or Vim 8.2.191+ with popupwin feature is required for pop-up window'
    2              0.000002         end
    2   0.001627   0.000022         call s:popup(a:dict.window)
    2              0.000005         let is_popup = 1
                                  else
                                    execute 'keepalt' a:dict.window
    2              0.000002       endif
                                elseif !s:splittable(a:dict)
                                  execute (tabpagenr()-1).'tabnew'
                                else
                                  for [dir, triple] in items(directions)
                                    let val = get(a:dict, dir, '')
                                    if !empty(val)
                                      let [cmd, resz, max] = triple
                                      if (dir == 'up' || dir == 'down') && val[0] == '~'
                                        let sz = s:calc_size(max, val, a:dict)
                                      else
                                        let sz = s:calc_size(max, val, {})
                                      endif
                                      execute cmd sz.'new'
                                      execute resz sz
                                      return [ppos, {}, is_popup]
                                    endif
                                  endfor
    2              0.000002     endif
    2              0.000013     return [ppos, is_popup ? {} : { '&l:wfw': &l:wfw, '&l:wfh': &l:wfh }, is_popup]
    2              0.000004   finally
    2              0.000003     if !is_popup
                                  setlocal winfixwidth winfixheight
    2              0.000002     endif
    2              0.000003   endtry

FUNCTION  <SNR>17_popup_support()
    Defined: ~/.system/config/nvim/plugged/fzf/plugin/fzf.vim line 125
Called 4 times
Total time:   0.000046
 Self time:   0.000046

count  total (s)   self (s)
    4              0.000043   return has('nvim') ? has('nvim-0.4') : has('popupwin') && has('patch-8.2.191')

FUNCTION  10()
    Defined: ~/.system/config/nvim/plugged/fzf/plugin/fzf.vim line 392
Called 1 time
Total time:   0.007643
 Self time:   0.000008

count  total (s)   self (s)
    1   0.007642   0.000008       return s:common_sink(self._action, a:lines)

FUNCTION  <SNR>17_evaluate_opts()
    Defined: ~/.system/config/nvim/plugged/fzf/plugin/fzf.vim line 335
Called 4 times
Total time:   0.000298
 Self time:   0.000104

count  total (s)   self (s)
    4   0.000295   0.000101   return type(a:options) == type([]) ? join(map(copy(a:options), 'fzf#shellescape(v:val)')) : a:options

FUNCTION  <SNR>17_border_opt()
    Defined: ~/.system/config/nvim/plugged/fzf/plugin/fzf.vim line 696
Called 2 times
Total time:   0.000239
 Self time:   0.000115

count  total (s)   self (s)
    2              0.000009   if type(a:window) != type({})
                                return ''
    2              0.000002   endif
                            
                              " Border style
    2              0.000014   let style = tolower(get(a:window, 'border', 'rounded'))
    2              0.000011   if !has_key(a:window, 'border') && !get(a:window, 'rounded', 1)
                                let style = 'sharp'
    2              0.000001   endif
    2              0.000006   if style == 'none' || style == 'no'
                                return ''
    2              0.000001   endif
                            
                              " For --border styles, we need fzf 0.24.0 or above
    2   0.000142   0.000018   call fzf#exec('0.24.0')
    2              0.000007   let opt = ' --border=' . style
    2              0.000006   if has_key(a:window, 'highlight')
                                let color = s:get_color('fg', a:window.highlight)
                                if len(color)
                                  let opt .= ' --color=border:' . color
                                endif
    2              0.000001   endif
    2              0.000003   return opt

FUNCTION  LanguageClient#handleTextChanged()
    Defined: ~/.system/config/nvim/plugged/LanguageClient-neovim/autoload/LanguageClient.vim line 1155
Called 54 times
Total time:   0.005501
 Self time:   0.001365

count  total (s)   self (s)
   54              0.000210     if &buftype !=# '' || &filetype ==# '' || expand('%') ==# ''
                                    return
   54              0.000019     endif
                            
   54              0.000039     try
                                    " Note: do not add 'text' as it might be huge.
   54   0.004729   0.000593         call LanguageClient#Notify('languageClient/handleTextChanged', { 'filename': LSP#filename(), })
                                catch
                                    call s:Debug('LanguageClient caught exception: ' . string(v:exception))
   54              0.000039     endtry

FUNCTION  <SNR>36_ExecuteAutocmd()
    Defined: ~/.system/config/nvim/plugged/LanguageClient-neovim/autoload/LanguageClient.vim line 1096
Called 26 times
Total time:   0.000130
 Self time:   0.000130

count  total (s)   self (s)
   26              0.000086     if exists('#User#' . a:event)
                                    execute 'doautocmd <nomodeline> User ' . a:event
   26              0.000009     endif

FUNCTION  <SNR>11_SynSet()
    Defined: /usr/share/nvim/runtime/syntax/synload.vim line 33
Called 4 times
Total time:   0.004058
 Self time:   0.000792

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
    4              0.000012   syn clear
    4              0.000007   if exists("b:current_syntax")
                                unlet b:current_syntax
    4              0.000002   endif
                            
    4              0.000008   let s = expand("<amatch>")
    4              0.000004   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
    4              0.000004   elseif s == "OFF"
                                let s = ""
    4              0.000001   endif
                            
    4              0.000003   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.
    8              0.000019     for name in split(s, '\.')
    4   0.003951   0.000685       exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
    8              0.000005     endfor
    4              0.000002   endif

FUNCTION  <SNR>17_dopopd()
    Defined: ~/.system/config/nvim/plugged/fzf/plugin/fzf.vim line 541
Called 8 times
Total time:   0.000270
 Self time:   0.000209

count  total (s)   self (s)
    8              0.000030   if !exists('w:fzf_pushd')
    4              0.000006     return
    4              0.000001   endif
                            
                              " FIXME: We temporarily change the working directory to 'dir' entry
                              " of options dictionary (set to the current working directory if not given)
                              " before running fzf.
                              "
                              " e.g. call fzf#run({'dir': '/tmp', 'source': 'ls', 'sink': 'e'})
                              "
                              " After processing the sink function, we have to restore the current working
                              " directory. But doing so may not be desirable if the function changed the
                              " working directory on purpose.
                              "
                              " So how can we tell if we should do it or not? A simple heuristic we use
                              " here is that we change directory only if the current working directory
                              " matches 'dir' entry. However, it is possible that the sink function did
                              " change the directory to 'dir'. In that case, the user will have an
                              " unexpected result.
    4   0.000085   0.000043   if s:fzf_getcwd() ==# w:fzf_pushd.dir && (!&autochdir || w:fzf_pushd.bufname ==# bufname(''))
    4   0.000111   0.000092     execute w:fzf_pushd.command s:escape(w:fzf_pushd.origin)
    4              0.000002   endif
    4              0.000005   unlet! w:fzf_pushd

FUNCTION  <SNR>17_validate_layout()
    Defined: ~/.system/config/nvim/plugged/fzf/plugin/fzf.vim line 325
Called 2 times
Total time:   0.000062
 Self time:   0.000062

count  total (s)   self (s)
    4              0.000014   for key in keys(a:layout)
    2              0.000008     if index(s:layout_keys, key) < 0
                                  throw printf('Invalid entry in g:fzf_layout: %s (allowed: %s)%s', key, join(s:layout_keys, ', '), key == 'options' ? '. Use $FZF_DEFAULT_OPTS.' : '')
    2              0.000002     endif
    4              0.000004   endfor
    2              0.000004   return a:layout

FUNCTION  <SNR>18_fzf_vim_term()
    Defined: ~/.system/config/nvim/plugged/fzf.vim/plugin/fzf.vim line 112
Called 2 times
Total time:   0.000091
 Self time:   0.000044

count  total (s)   self (s)
    2              0.000005     if get(w:, 'airline_active', 0)
                                  let w:airline_disabled = 1
                                  autocmd BufWinLeave <buffer> let w:airline_disabled = 0
    2              0.000001     endif
    2              0.000014     autocmd WinEnter,ColorScheme <buffer> call s:fzf_restore_colors()
                            
    2              0.000007     setlocal nospell
    2   0.000059   0.000012     call s:fzf_restore_colors()

FUNCTION  fzf#run()
    Defined: ~/.system/config/nvim/plugged/fzf/plugin/fzf.vim line 414
Called 2 times
Total time:   0.008825
 Self time:   0.000562

count  total (s)   self (s)
    2              0.000004 try
    2   0.000118   0.000036   let [shell, shellslash, shellcmdflag, shellxquote] = s:use_sh()
                            
    2              0.000017   let dict   = exists('a:1') ? copy(a:1) : {}
    2   0.000059   0.000025   let temps  = { 'result': s:fzf_tempname() }
    2   0.000044   0.000025   let optstr = s:evaluate_opts(get(dict, 'options', ''))
    2              0.000002   try
    2   0.000235   0.000036     let fzf_exec = fzf#shellescape(fzf#exec())
                              catch
                                throw v:exception
    2              0.000004   endtry
                            
    2              0.000007   if !has_key(dict, 'dir')
    2   0.000057   0.000022     let dict.dir = s:fzf_getcwd()
    2              0.000002   endif
    2              0.000016   if has('win32unix') && has_key(dict, 'dir')
                                let dict.dir = fnamemodify(dict.dir, ':p')
    2              0.000002   endif
                            
    2              0.000006   if has_key(dict, 'source')
                                let source = dict.source
                                let type = type(source)
                                if type == 1
                                  let prefix = '( '.source.' )|'
                                elseif type == 3
                                  let temps.input = s:fzf_tempname()
                                  call writefile(source, temps.input)
                                  let prefix = (s:is_win ? 'type ' : 'cat ').fzf#shellescape(temps.input).'|'
                                else
                                  throw 'Invalid source type'
                                endif
    2              0.000002   else
    2              0.000004     let prefix = ''
    2              0.000002   endif
                            
    2              0.000014   let prefer_tmux = get(g:, 'fzf_prefer_tmux', 0) || has_key(dict, 'tmux')
    2              0.000023   let use_height = has_key(dict, 'down') && !has('gui_running') && !(has('nvim') || s:is_win || has('win32unix') || s:present(dict, 'up', 'left', 'right', 'window')) && executable('tput') && filereadable('/dev/tty')
    2              0.000014   let has_vim8_term = has('terminal') && has('patch-8.0.995')
    2              0.000014   let has_nvim_term = has('nvim-0.2.1') || has('nvim') && !s:is_win
    2              0.000017   let use_term = has_nvim_term || has_vim8_term && !has('win32unix') && (has('gui_running') || s:is_win || !use_height && s:present(dict, 'down', 'up', 'left', 'right', 'window'))
    2              0.000022   let use_tmux = (has_key(dict, 'tmux') || (!use_height && !use_term || prefer_tmux) && !has('win32unix') && s:splittable(dict)) && s:tmux_enabled()
    2              0.000004   if prefer_tmux && use_tmux
                                let use_height = 0
                                let use_term = 0
    2              0.000002   endif
    2              0.000003   if use_height
                                let height = s:calc_size(&lines, dict.down, dict)
                                let optstr .= ' --height='.height
    2              0.000003   elseif use_term
    2              0.000007     let optstr .= ' --no-height'
    2              0.000002   endif
    2   0.000269   0.000030   let optstr .= s:border_opt(get(dict, 'window', 0))
    2              0.000022   let command = prefix.(use_tmux ? s:fzf_tmux(dict) : fzf_exec).' '.optstr.' > '.temps.result
                            
    2              0.000003   if use_term
    2   0.007694   0.000038     return s:execute_term(dict, command, temps)
                              endif
                            
                              let lines = use_tmux ? s:execute_tmux(dict, command, temps) : s:execute(dict, command, use_height, temps)
                              call s:callback(dict, lines)
                              return lines
    2              0.000001 finally
    2              0.000016   let [&shell, &shellslash, &shellcmdflag, &shellxquote] = [shell, shellslash, shellcmdflag, shellxquote]
    2              0.000001 endtry

FUNCTION  <SNR>17_cmd()
    Defined: ~/.system/config/nvim/plugged/fzf/plugin/fzf.vim line 963
Called 2 times
Total time:   0.010465
 Self time:   0.000259

count  total (s)   self (s)
    2              0.000021   let args = copy(a:000)
    2              0.000012   let opts = { 'options': ['--multi'] }
    2              0.000015   if len(args) && isdirectory(expand(args[-1]))
                                let opts.dir = substitute(substitute(remove(args, -1), '\\\(["'']\)', '\1', 'g'), '[/\\]*$', '/', '')
                                if s:is_win && !&shellslash
                                  let opts.dir = substitute(opts.dir, '/', '\\', 'g')
                                endif
                                let prompt = opts.dir
    2              0.000002   else
    2   0.000164   0.000033     let prompt = s:shortpath()
    2              0.000002   endif
    2              0.000018   let prompt = strwidth(prompt) < &columns - 20 ? prompt : '> '
    2              0.000020   call extend(opts.options, ['--prompt', prompt])
    2              0.000007   call extend(opts.options, args)
    2   0.010162   0.000087   call fzf#run(fzf#wrap('FZF', opts, a:bang))

FUNCTION  LanguageClient#handleBufEnter()
    Defined: ~/.system/config/nvim/plugged/LanguageClient-neovim/autoload/LanguageClient.vim line 1123
Called 12 times
Total time:   0.003310
 Self time:   0.000895

count  total (s)   self (s)
   12              0.000090     if !exists('b:LanguageClient_isServerRunning')
    2              0.000003       let b:LanguageClient_isServerRunning = 0
   12              0.000015     endif
                            
   12              0.000092     if !exists('b:LanguageClient_statusLineDiagnosticsCounts')
    2              0.000003       let b:LanguageClient_statusLineDiagnosticsCounts = {}
   12              0.000010     endif
                            
   12              0.000022     try
   12   0.002791   0.000376         call LanguageClient#Notify('languageClient/handleBufEnter', { 'filename': LSP#filename(), })
                                catch
                                    call s:Debug('LanguageClient caught exception: ' . string(v:exception))
   12              0.000027     endtry

FUNCTION  <SNR>17_exit_handler()
    Defined: ~/.system/config/nvim/plugged/fzf/plugin/fzf.vim line 583
Called 2 times
Total time:   0.000034
 Self time:   0.000034

count  total (s)   self (s)
    2              0.000003   if a:code == 130
                                return 0
    2              0.000008   elseif has('nvim') && a:code == 129
                                " When deleting the terminal buffer while fzf is still running,
                                " Nvim sends SIGHUP.
                                return 0
    2              0.000002   elseif a:code > 1
                                call s:error('Error running ' . a:command)
                                if !empty(a:000)
                                  sleep
                                endif
                                return 0
    2              0.000001   endif
    2              0.000002   return 1

FUNCTION  <SNR>17_fzf_getcwd()
    Defined: ~/.system/config/nvim/plugged/fzf/plugin/fzf.vim line 102
Called 14 times
Total time:   0.000186
 Self time:   0.000102

count  total (s)   self (s)
   14   0.000181   0.000096   return s:fzf_call('getcwd')

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
 1274   0.361673   0.316118  <SNR>36_HandleMessage()
  338   0.070965   0.021729  LanguageClient#handleCursorMoved()
  449   0.042251             <SNR>25_Highlight_Matching_Pair()
  318   0.029568   0.016647  LanguageClient#Notify()
 1578   0.028265             LanguageClient#Write()
  390   0.018509             LSP#filename()
  322   0.014762   0.010687  <SNR>36_set_virtual_texts()
    2   0.013851   0.000079  <SNR>17_callback()
    2   0.013669   0.000199  <SNR>17_common_sink()
    2   0.013450   0.004244  <SNR>17_open()
    2   0.010465   0.000259  <SNR>17_cmd()
    1   0.009506   0.000840  12()
    2   0.008825   0.000562  fzf#run()
  276   0.007929   0.002379  LSP#position()
    2   0.007656   0.003189  <SNR>17_execute_term()
    1   0.007643   0.000008  10()
    1   0.007187   0.000573  9()
    1   0.006042   0.000007  7()
  276   0.005550   0.003816  <SNR>37_get_position()
   54   0.005501   0.001365  LanguageClient#handleTextChanged()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
 1274   0.361673   0.316118  <SNR>36_HandleMessage()
  449              0.042251  <SNR>25_Highlight_Matching_Pair()
 1578              0.028265  LanguageClient#Write()
  338   0.070965   0.021729  LanguageClient#handleCursorMoved()
  390              0.018509  LSP#filename()
  318   0.029568   0.016647  LanguageClient#Notify()
  322   0.014762   0.010687  <SNR>36_set_virtual_texts()
  318              0.004879  <SNR>36_SkipSendingMessage()
   56              0.004587  LSP#text()
    2   0.013450   0.004244  <SNR>17_open()
  324              0.004100  <SNR>36_GetVar()
  276   0.005550   0.003816  <SNR>37_get_position()
  266              0.003323  <SNR>36_set_signs()
    2   0.007656   0.003189  <SNR>17_execute_term()
  276   0.007929   0.002379  LSP#position()
  354              0.002299  LSP#viewport()
    4   0.003201   0.002028  <SNR>8_LoadFTPlugin()
   54   0.005501   0.001365  LanguageClient#handleTextChanged()
  276              0.000975  LSP#line()
   12   0.003310   0.000895  LanguageClient#handleBufEnter()

